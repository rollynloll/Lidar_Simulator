<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: Improving I/O Performance When Working with HDF5 Compressed Datasets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better serve our user community by answering the following short survey:  <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;1.14.6</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_f_t_s.html"><span>Full-Text&#160;Search</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('improve_compressed_perf.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Improving I/O Performance When Working with HDF5 Compressed Datasets</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Internal compression is one of several powerful HDF5 features that distinguish HDF5 from other binary formats and make it very attractive for storing and organizing data. Internal HDF5 compression saves storage space and I/O bandwidth and allows efficient partial access to data. Chunked storage has to be used when HDF5 compression is enabled.</p>
<p>Certain combinations of compression, chunked storage, and access pattern may cause I/O performance degradation if used inappropriately, but the HDF5 Library provides tuning parameters to achieve I/O performance comparable with the I/O performance on raw data that uses contiguous storage.</p>
<p>In this paper, we discuss the factors that should be considered when storing compressed data in HDF5 files and how to tune those parameters to optimize the I/O performance of an HDF5 application when working with compressed datasets.</p>
<ul>
<li>
<a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_intro">Introduction</a> </li>
<li>
<a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_case">Case Study</a> </li>
<li>
<a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_chunk">Chunking and Compression in HDF5</a> </li>
<li>
<a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_tune">Tuning for Performance</a> </li>
<li>
<a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_rec">Recommendations</a> </li>
</ul>
<h1><a class="anchor" id="sec_improve_compressed_perf_intro"></a>
Introduction</h1>
<p>One of the most powerful features of HDF5 is its ability to store and modify compressed data. The HDF5 Library comes with two pre-defined compression methods, GNU <b>zip</b> or <b>gzip</b> and <b>szip</b> or <b>libaec</b>, and has the capability to use third-party compression methods, <a class="el" href="_h5_d__u_g.html#subsubsec_dataset_filters_dyn">Using Dynamically-Loadable Filters</a>. The variety of available compression methods means users can choose the compression method that is best suited for achieving the desired balance between the CPU time needed to compress or un-compress data and storage performance.</p>
<p>Compressed data is stored in a data array of an HDF5 dataset using a chunked storage mechanism. When chunked storage is used, the data array is split into equally sized chunks each of which is stored separately in the file. </p><table class="doxtable">
<caption>Data array is logically split into equally sized chunks each of which is stored separately in the file</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_1.png" alt=""/>
<div class="caption">
Figure 1</div></div>
  </td></tr>
</table>
<p>Compression is applied to each individual chunk. When an I/O operation is performed on a subset of the data array, only chunks that include data from the subset participate in I/O and need to be uncompressed or compressed. </p><table class="doxtable">
<caption>Library will only read highlighted chunks when reading selected columns</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_2.png" alt=""/>
<div class="caption">
Figure 2</div></div>
  </td></tr>
</table>
<p>Chunked storage also enables adding more data to a dataset without rewriting the whole dataset. Figure 3 below shows more rows and columns added to a data array stored in HDF5 by writing highlighted chunks that contain new data. </p><table class="doxtable">
<caption>More rows and columns were added to the dataset</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_3.png" alt=""/>
<div class="caption">
Figure 3</div></div>
  </td></tr>
</table>
<p>While HDF5 chunk storage and compression obviously provide great benefits in working with data, many HDF5 users have found that sometimes I/O performance is slower for compressed data than for uncompressed data. For example, as we show in this paper, there may be a huge performance difference between an application reading compressed data and reading the same data that was not compressed. For an application that writes compressed data, I/O performance may be excellent, but when data is moved to another system and read back, I/O performance drastically drops making data virtually unusable.</p>
<p>Many of these cases of drastically slower reading performance can be ameliorated by more careful consideration of avoiding chunking arrangements that may cause poor reading performance when creating datasets or by a few simple changes to the application reading the data. In this paper, we will discuss the factors that should be considered when storing compressed data in HDF5 files and when tuning an HDF5 application that writes or reads compressed data. We assume that the reader knows HDF5 <a class="el" href="_learn_basics.html">Learning the Basics</a> and would like to learn a set of performance tuning techniques when working with compressed data.</p>
<p>In our discussion, we use an HD5 file with Cross-track Infrared Sounder (CriS) data from the Suomi NPP satellite to illustrate several performance tuning techniques for HDF5 applications. The paper is organized as follows: </p><ul>
<li>The structure of the file and the properties of the datasets are discussed in the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_case">Case Study</a> section. </li>
<li>In the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_chunk">Chunking and Compression in HDF5</a> section, we review HDF5 chunking and compression features in more detail. </li>
<li>In the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_tune">Tuning for Performance</a> section, we discuss the performance tuning approach. </li>
<li>The <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_rec">Recommendations</a> section summarizes our recommendations.</li>
</ul>
<p>In the near future, we intend to make available a new CCP (Chunking and Compression Performance) tool. This tool will allow users to vary access patterns, chunk sizes, compression method, and cache settings using the tool’s command options, reducing the need to create and compile test programs such as those used in the “Case Study” section on page 7.</p>
<p>For more information on other things that can affect performance, see the “Things That Can Affect Performance” page in the FAQ on the website.</p>
<h1><a class="anchor" id="sec_improve_compressed_perf_case"></a>
Case Study</h1>
<p>We will use two HDF5 files to compare I/O performance and to illustrate the issues users may encounter when working with compressed data. These HDF5 files and the application programs used to read them can be downloaded [ 7 ] by readers wishing to reproduce the performance results discussed in this paper.<sup>1</sup> </p><ul>
<li><sup>1</sup>:Performance results provided in the paper are intended to show the difference in performance when different HDF5 parameters are used. The reader should be aware that the numbers on his/her system would differ from those provided in the paper, but the effect of the HDF5 parameters should be the same.</li>
</ul>
<p><code>SCRIS_npp_d20140522_t0754579_e0802557_b13293_c20140522142425734814_noaa_pop.h5</code> is the first file we will use. It is an original data file with Cross-track Infrared Sounder (CriS) data from the Suomi NPP satellite. For brevity, we will refer to this file in this document as <code>File.h5</code>.</p>
<p>The second file is <code>gz6_SCRIS_npp_d20140522_t0754579_e0802557_b13293__noaa_pop.h5</code>. We will refer to this file as <code>File_with_compression.h5</code>. The file was created from <code>File.h5</code> by the <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> tool that applied the <b>gzip</b> compression to all datasets using level 6 effort. Repacking <code>File.h5</code> using <b>gzip</b> compression reduced the storage space by 1.3 times. We will use the file to demonstrate the most common issues HDF5 users encounter when working with compressed data in HDF5.</p>
<p>We selected these files because they have characteristics that would be the first ones to look at when tuning I/O performance of both writing and reading HDF5 applications. First, this data file represents files generated on a big-endian system that is usually not available to general users of the data. The data provider used the HDF5 parameters to minimize storage space for data and to maximize write speed that were not necessarily the optimum parameters for the systems where the data would be read. Second, the users’ applications read data in a way that was optimized for scientific data analysis but not optimal for the HDF5 I/O performance. We will use the files to show what the users can do to improve performance of their applications, and which factors data providers should consider before creating data products.</p>
<p>In our case study, we used a 4-dimensional array of 32-bit big-endian floating point numbers stored in the HDF5 dataset <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> in both files. The data array is extensible and has the current dimension sizes 60x30x9x717. When compressed with <b>gzip</b> compression with level 6, the compression ratio is 1.076<sup>2</sup>. We used HDF5 command line tools <a class="el" href="_h5_t_o_o_l__d_p__u_g.html#sec_cltools_h5dump">h5dump</a> and <a class="el" href="_h5_t_o_o_l__l_s__u_g.html#sec_cltools_h5ls">h5ls</a> and the HDF Java-based browser HDFView to find various properties of the dataset that would help us to understand performance problems and propose solutions. If the reader decides to follow the discussion using a “hands on” approach, the examples below illustrate how to use h5dump and h5ls to get the characteristics of the <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> dataset. </p><ul>
<li><sup>2</sup>:The ratio itself is not a subject of this paper, but the fact that the dataset was compressed is. It is one of the factors that affected the performance. While the total compression ratio for the file is 1.3, one should be careful about applying the same compression to all datasets in a file. For some datasets, compression will not significantly reduce storage space while requiring extra I/O time for decompression as this example shows.</li>
</ul>
<p>The <a class="el" href="_h5_t_o_o_l__d_p__u_g.html#sec_cltools_h5dump">h5dump</a> command line below will yield the results shown in Figure 4 below: </p><div class="fragment"><div class="line">% h5dump -H -d /All_Data/CrIS-SDR_All/ES_ImaginaryLW File_with_compression.h5</div>
<div class="line"> </div>
<div class="line">HDF5 <span class="stringliteral">&quot;gz6_SCRIS_npp_d20140522_t0754579_e0802557_b13293__noaa_pop.h5&quot;</span> {</div>
<div class="line">DATASET <span class="stringliteral">&quot;/All_Data/CrIS-SDR_All/ES_ImaginaryLW&quot;</span> {</div>
<div class="line">   DATATYPE <a class="code hl_define" href="group___p_d_t_i_e_e_e.html#ga71d24a7d4c373ed9a003d7a0d8133f1e">H5T_IEEE_F32BE</a></div>
<div class="line">   DATASPACE SIMPLE { ( 60, 30, 9, 717 ) / ( <a class="code hl_define" href="_h5_spublic_8h.html#a5af9ab788797b2ea9a4843857674ac18">H5S_UNLIMITED</a>,</div>
<div class="line"><a class="code hl_define" href="_h5_spublic_8h.html#a5af9ab788797b2ea9a4843857674ac18">H5S_UNLIMITED</a>, <a class="code hl_define" href="_h5_spublic_8h.html#a5af9ab788797b2ea9a4843857674ac18">H5S_UNLIMITED</a>, <a class="code hl_define" href="_h5_spublic_8h.html#a5af9ab788797b2ea9a4843857674ac18">H5S_UNLIMITED</a> ) }</div>
<div class="line">   STORAGE_LAYOUT {</div>
<div class="line">      CHUNKED ( 4, 30, 9, 717 )</div>
<div class="line">      SIZE 43162046 (1.076:1 COMPRESSION)</div>
<div class="line">   }</div>
<div class="line">   FILTERS {</div>
<div class="line">      COMPRESSION DEFLATE { LEVEL 6 }</div>
<div class="line">   }</div>
<div class="line">   FILLVALUE {</div>
<div class="line">      FILL_TIME <a class="code hl_enumvalue" href="_h5_dpublic_8h.html#aa39293626c4e68dd28b06c0dc84bde4aa85b225308b0a277c4dd6fed7ee465a72">H5D_FILL_TIME_IFSET</a></div>
<div class="line">      VALUE -999.3</div>
<div class="line">   }</div>
<div class="line">   ALLOCATION_TIME {</div>
<div class="line">      <a class="code hl_enumvalue" href="_h5_dpublic_8h.html#aab70b464cf3c5fc931dce0c4fe98b3d2ac898a96931fd3402d9e5646690c77636">H5D_ALLOC_TIME_INCR</a></div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="ttc" id="a_h5_dpublic_8h_html_aa39293626c4e68dd28b06c0dc84bde4aa85b225308b0a277c4dd6fed7ee465a72"><div class="ttname"><a href="_h5_dpublic_8h.html#aa39293626c4e68dd28b06c0dc84bde4aa85b225308b0a277c4dd6fed7ee465a72">H5D_FILL_TIME_IFSET</a></div><div class="ttdeci">@ H5D_FILL_TIME_IFSET</div><div class="ttdef"><b>Definition</b> H5Dpublic.h:102</div></div>
<div class="ttc" id="a_h5_dpublic_8h_html_aab70b464cf3c5fc931dce0c4fe98b3d2ac898a96931fd3402d9e5646690c77636"><div class="ttname"><a href="_h5_dpublic_8h.html#aab70b464cf3c5fc931dce0c4fe98b3d2ac898a96931fd3402d9e5646690c77636">H5D_ALLOC_TIME_INCR</a></div><div class="ttdeci">@ H5D_ALLOC_TIME_INCR</div><div class="ttdef"><b>Definition</b> H5Dpublic.h:77</div></div>
<div class="ttc" id="a_h5_spublic_8h_html_a5af9ab788797b2ea9a4843857674ac18"><div class="ttname"><a href="_h5_spublic_8h.html#a5af9ab788797b2ea9a4843857674ac18">H5S_UNLIMITED</a></div><div class="ttdeci">#define H5S_UNLIMITED</div><div class="ttdef"><b>Definition</b> H5Spublic.h:48</div></div>
<div class="ttc" id="agroup___p_d_t_i_e_e_e_html_ga71d24a7d4c373ed9a003d7a0d8133f1e"><div class="ttname"><a href="group___p_d_t_i_e_e_e.html#ga71d24a7d4c373ed9a003d7a0d8133f1e">H5T_IEEE_F32BE</a></div><div class="ttdeci">#define H5T_IEEE_F32BE</div><div class="ttdef"><b>Definition</b> H5Tpublic.h:267</div></div>
</div><!-- fragment --><p> <em>Figure 4: Output of the h5dump command that shows properties of the dataset /All_Data/CrIS-SDR_All/ES_ImaginaryLW</em></p>
<p>The <a class="el" href="_h5_t_o_o_l__l_s__u_g.html#sec_cltools_h5ls">h5ls</a> command line below will yield the results shown in Figure 5 below: </p><div class="fragment"><div class="line">% h5ls -lrv gz6_SCRIS_npp_d20140522_t0754579_e0802557_b13293__noaa_pop.h5</div>
<div class="line"> </div>
<div class="line">/All_Data/CrIS-SDR_All/ES_ImaginaryLW Dataset {60/Inf, 30/Inf, 9/Inf,</div>
<div class="line">717/Inf}</div>
<div class="line">    Location: 1:60464</div>
<div class="line">    Links:    1</div>
<div class="line">    Chunks:   {4, 30, 9, 717} 3097440 bytes</div>
<div class="line">    Storage:  46461600 logical bytes, 43162046 allocated bytes, 107.64%</div>
<div class="line">utilization</div>
<div class="line">    Filter-0: deflate-1 OPT {6}</div>
<div class="line">    Type:     IEEE 32-bit big-endian <span class="keywordtype">float</span></div>
</div><!-- fragment --><p> <em>Figure 5: Output of the h5ls command that shows properties of the dataset /All_Data/CrIS-SDR_All/ES_ImaginaryLW</em></p>
<p>In HDFView, right click on the dataset to choose “Show Properties” option from the drop-down menu. The properties will appear in the new window as shown in Figure 6. </p><table class="doxtable">
<caption>HDFView window with information about the dataset</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_6.png" alt=""/>
<div class="caption">
Figure 6</div></div>
  </td></tr>
</table>
<p>Our application read the dataset along the fastest changing dimension, 717 elements at a time from the dataset in both files. In the 2-dimensional case, this would correspond to reading an array by “row”. There were 16,200 reads to get all of the data. What we found was a several orders of magnitude drop in the performance when data was read from the compressed dataset as shown in Table 1. </p><table class="doxtable">
<caption>Table 1: Reading by 1x1x717 hyperslab (or “rows”) from original and compressed datasets. Performance drops more than 3000 times.</caption>
<tr>
<th>File Name</th><td>File.h5</td><td>File_with_compression.h5 (gzip level 6) </td></tr>
<tr>
<th>Read Time</th><td>0.1 seconds</td><td>0.37 seconds </td></tr>
</table>
<p>We experimented with the HDF5 parameters such cache size and chunk size and modified our application to use different access patterns. The details of the experiments and achieved results will be discussed in the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_tune">Tuning for Performance</a> section. Here we provide the results just to show the difference in the read performance the change in the parameters made.</p>
<p>The table below, Table 2, shows the result of reading data as in the example above with the difference that the application used a chunked cache size of 3MB instead of the default 1MB. Reading performance from the compressed dataset was only 4 times slower than for reading the uncompressed data. </p><table class="doxtable">
<caption>Table 2: Reading by 1x1x717 hyperslab (or “rows”) from original and compressed datasets. Changing the chunk cache size from 1MB to 3MB improved application performance by a factor of 1000.</caption>
<tr>
<th>File Name</th><td>File.h5</td><td>File_with_compression.h5 (gzip level 6) </td></tr>
<tr>
<th>Read Time</th><td>0.1 seconds</td><td>0.37 seconds </td></tr>
</table>
<p>We also experimented with a different access pattern to read data from both files. Instead of reading 717 elements at a time, we read a contiguous HDF5 hyperslab with dimensions 4x30x9x717. The reader who knows about HDF5 chunking will immediately recognize that we read one chunk at a time, a total 15 of them. With this change, reading from the non-compressed dataset was only 10 times better than reading from the compressed dataset; see Table 3 below and compare with the results in Table 1. </p><table class="doxtable">
<caption>Table 3: Reading by 4x30x9x717 hyperslabs from original and compressed datasets. Performance for compressed dataset is several orders of magnitude better than the result in Table 1 and comparable to the result in Table 2.</caption>
<tr>
<th>File Name</th><td>File.h5</td><td>File_with_compression.h5 (gzip level 6) </td></tr>
<tr>
<th>Read Time</th><td>0.04 seconds</td><td>0.36 seconds </td></tr>
</table>
<p>In our last experiment, we repacked both files with <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> to use a chunk size of 1x30x9x717, 4 times smaller than the original chunks, and read the file by using the original access pattern of 1x1x1x717 hyperslab (by “row”). The result is shown below in Table 4. Once again, we got much better performance than shown in Table 1, even when considering the time to repack the file with h5repack. </p><table class="doxtable">
<caption>Table 4: Reading by 1x1x1x717 hyperslab (by “row”) from non-compressed and compressed datasets; a smaller chunk size of 1x30x9x717 was used to store data in both files. Performance for the compressed dataset is comparable to the result in Table 2 and Table 3.</caption>
<tr>
<th>File Name</th><td>File.h5</td><td>File_with_compression-small-chunk.h5 (gzip level 6) </td></tr>
<tr>
<th>Read Time</th><td>0.08 seconds</td><td>0.36 seconds </td></tr>
<tr>
<th>Repack Time</th><td>3 seconds</td><td>12 seconds </td></tr>
</table>
<ul>
<li>Note that the read and repack times in the tables above are approximate values.</li>
</ul>
<h1><a class="anchor" id="sec_improve_compressed_perf_chunk"></a>
Chunking and Compression in HDF5</h1>
<p>In this section we will give a brief overview of the chunking and compression features needed to follow the approach presented later in the “Tuning for Performance” section on page 15. For more information on HDF5 chunking, see the <a class="el" href="hdf5_chunking.html">Chunking in HDF5</a> document.</p>
<h2><a class="anchor" id="subsec_improve_compressed_perf_chunk_chunk"></a>
Chunking in HDF5</h2>
<p>Data of HDF5 dataset can be stored in several different ways in HDF5 file. See the <a class="el" href="_h5_d__u_g.html#subsubsec_dataset_program_transfer">Data Transfer Operations on a Dataset</a> section in the <a class="el" href="_h5_d__u_g.html#sec_dataset">HDF5 Datasets</a> chapter in the <a class="el" href="_u_g.html">HDF5 User Guide</a> for more information.</p>
<p>The default storage layout of HDF5 files is contiguous storage: data of a multidimensional array is serialized (or flattened) along the fastest changing dimension and is stored as a contiguous block in the file. This storage mechanism is recommended if the size of a dataset is known and the storage size for the dataset is acceptable to the user: in other words, no data compression is desired. The contiguous storage is efficient for I/O if a whole HDF5 dataset is accessed or if a contiguous subset (as stored in the file) of an HDF5 dataset is accessed. The figure below shows an example with a row of a 2-dimensional array stored in an HDF5 dataset by a C application. In this case, the HDF5 Library seeks to the start position in the file and writes/reads the required number of bytes. </p><table class="doxtable">
<caption>Elements of the rows of the 6x9 two-dimensional array are stored contiguously in the file while elements of the columns are not</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_7.png" alt=""/>
<div class="caption">
Figure 7</div></div>
  </td></tr>
</table>
<p>If we change the access pattern to accessing the dataset by columns instead of by rows, the contiguous layout may not work well. The column’s elements are not stored contiguously in the file (see Figure 8). Accessing a column will require several seeks to find the data in the file and multiple reads/writes of one element at a time. Seeks and small size I/O operations may affect performance especially for large datasets. Obviously, contiguous storage is not as favorable for a column access pattern as it is for a row access pattern, and other storage options may be more beneficial. </p><table class="doxtable">
<caption>Elements of the column are not stored contiguously in the file</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_8.png" alt=""/>
<div class="caption">
Figure 8</div></div>
  </td></tr>
</table>
<p>An alternative is chunked storage (a chunked storage layout). When chunked storage is used, a multidimensional array is logically divided into equally sized chunks. For example, Figure 9 below shows the 6x9 array divided into 6 3x3 chunks. Chunked storage layout and chunk sizes (number of elements in a chunk along each dataset dimension) are specified at dataset creation time and cannot be changed without rewriting the dataset. Chunked storage is <b>required</b> if data will be added to an HDF5 dataset and <b>the maximum size of the dataset is unknown</b> at creation time (see Figure 3). Chunked storage is also <b>required</b> if data will be stored <b>compressed</b>.</p>
<p>The logical chunk is stored as a contiguous block in the file (compare with the contiguous storage when the whole data array is stored contiguously in the file). When compression is used, it is applied to each chunk separately. During the I/O operation each chunk is accessed as a whole when the HDF5 Library reads or writes data elements stored in the chunk. For example, two chunks will be read (and uncompressed if needed) when accessing the 2<sup>nd</sup> column as shown in Figure 9.</p>
<p><b>The chunk size is an important factor in achieving good I/O and storage performance</b>.</p>
<p>If the chunk size is too small, I/O performance degrades due to small reads/writes when a chunk is accessed. Storing a large number of small chunks increases the size of the internal HDF5 data structures needed to track the positions and sizes of chunks in the file, creating excessive storage overhead.</p>
<p>On the other hand, if the chunk size is too big and compression is used, I/O performance may degrade with unsuitable combinations of access patterns and chunk cache sizes or on systems that do not have enough memory to compress or to uncompress chunks. For instance, an application that reads data by row from a chunk too large to fit in the configured cache will cause decompression of the entire chunk for each row that is read, resulting in a great deal of unnecessarily repeated disk reads and decompression processing.</p>
<p>As was mentioned above, the storage layout cannot be changed after the dataset has been created. If desired, one can use the <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> tool to modify the storage layout of a copy of a dataset; for example, the tool can be used to change the size of the chunk, to remove compression and store the dataset using contiguous storage, or to apply a different compression method. If data is read from the file many times, it may be much more efficient to rewrite the file using <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> with the more appropriate storage parameters for reading, than to read data from the original file with an unfavorable compression and chunking arrangement. </p><table class="doxtable">
<caption>Each chunk is stored separately in the HDF5 file. Two chunks will be read by HDF5 to access the 2nd column of the array</caption>
<tr>
<td><div class="image">
<img src="improve_perf-compress_fig_9.png" alt=""/>
<div class="caption">
Figure 9</div></div>
  </td></tr>
</table>
<p><b>Another important aspect of HDF5 chunking is the chunk cache</b>.</p>
<p>HDF5 does not cache raw data unless chunked storage is used. When data is accessed for a chunked dataset, the chunks that contain the requested data are brought to the cache one by one and stay in cache until they are evicted. If a chunk is cached, then reading or writing data stored in the chunk does not require disk accesses. In other words, chunk caching helps when the same chunk is accessed multiple times during I/O operations.</p>
<p>The HDF5 Library provides the <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> functions to control the size of the chunk cache and the chunk eviction policy to specify the appropriate cache parameters for a particular access pattern.</p>
<p>As will be shown in the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_tune">Tuning for Performance</a> section, chunked storage and chunk cache parameters affect I/O performance and should be chosen with care depending on the I/O access pattern.</p>
<h2><a class="anchor" id="subsec_improve_compressed_perf_chunk_comp"></a>
Compression in HDF5</h2>
<p>As it was mentioned in the previous sections, in HDF5 data can be stored compressed. The HDF5 Library comes with the built-in compression methods: <table class="doxtable">
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#a9e802e9612b3647e7d3ffe4ce3b8dcce">H5Z_FILTER_DEFLATE</a></td><td>The gzip compression, or deflation, filter </td></tr>
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#a421d9941c68ebb776573baeb9aa77cd2">H5Z_FILTER_SZIP</a></td><td>The SZIP compressionfilter </td></tr>
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#a8cc463fa1979bd4bfa0dd9aa6a41e49d">H5Z_FILTER_NBIT</a></td><td>The N-bit compression filter </td></tr>
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#a745d2ccb4f7712ed78ef5e562e27d2ca">H5Z_FILTER_SCALEOFFSET</a></td><td>The scale-offset compression filter </td></tr>
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#aa723f1a71601bf22c95620a490ecf1af">H5Z_FILTER_SHUFFLE</a></td><td>The shuffle algorithm filter </td></tr>
<tr>
<td><a class="el" href="_h5_zpublic_8h.html#a59ca894c9c2b99b1614b0c46a7407f1c">H5Z_FILTER_FLETCHER32</a></td><td>The Fletcher32 checksum, or error checking, filter </td></tr>
</table>
 One can also build in a custom filter, <a class="el" href="_h5_d__u_g.html#subsec_dataset_filters">Using HDF5 Filters</a>, or use <a class="el" href="_h5_d__u_g.html#subsubsec_dataset_filters_dyn">Using Dynamically-Loadable Filters</a>.</p>
<p>The compression method is chosen at a dataset creation time and cannot be changed later. As with the chunked layout, one can use <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> to rewrite the dataset in a copy of the dataset using a different compression method or to remove compression completely.</p>
<p>HDF5 tools such <a class="el" href="_h5_t_o_o_l__d_p__u_g.html#sec_cltools_h5dump">h5dump</a> and <a class="el" href="_h5_t_o_o_l__l_s__u_g.html#sec_cltools_h5ls">h5ls</a> can be used to check the efficiency of the compression. For example, both <a class="el" href="_h5_t_o_o_l__d_p__u_g.html#sec_cltools_h5dump">h5dump</a> and <a class="el" href="_h5_t_o_o_l__l_s__u_g.html#sec_cltools_h5ls">h5ls</a> show the compression ratio for a dataset. The compression ratio is defined as a ratio of the original data size to the size of compressed data. For example, the ratio for the dataset <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> is 1.07 (see Figure 4) meaning that there was not much benefit in applying compression to save space in the file. For more information, see the <a class="el" href="_comp_t_s.html">HDF5 Compression Troubleshooting</a> technical note for a discussion of compression efficiency.</p>
<p>The HDF5 Library applies compression encoding or decoding when the chunk is moved between the chunk cache and the file. Since compression encoding and decoding takes CPU time, it affects HDF5 write and read performance. This is especially true when data is read or written many times from the same chunk and the chunk is not cached between the accesses; this means the chunk has to be brought from disk every time it is accessed.</p>
<p>In the next section we will see the effect of compression on the I/O performance.</p>
<h1><a class="anchor" id="sec_improve_compressed_perf_tune"></a>
Tuning for Performance</h1>
<p>In this section we will discuss several strategies one can apply to get better I/O performance. We will explain in detail how a particular strategy works and when it should be applied. While the examples below focus on reading only, the same approach will work for writing too.</p>
<p>The strategies for improving performance require modifications to the reading application or to the HDF5 file itself. The reader should choose the strategies that are appropriate for a particular use case.</p>
<h2><a class="anchor" id="subsec_improve_compressed_perf_tune_cache"></a>
Adjust Chunk Cache Size</h2>
<p>The HDF5 Library automatically creates a chunk cache for each opened chunked dataset. The first strategy is to check whether the current chunk cache settings work properly with the application access pattern and reset the chunk cache parameters as appropriate.</p>
<p>The HDF5 Library provides two functions, <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a>, to control chunk cache settings. <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> controls the chunk cache setting for ALL datasets in the file, and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> controls the chunk cache settings per dataset. To find out the default or current settings, use the <a class="el" href="group___f_a_p_l.html#ga9481a0b08d729ec68897d57db1827861" title="Queries the raw data chunk cache parameters.">H5Pget_cache</a> or <a class="el" href="group___d_a_p_l.html#gaeda015dfee4167cc60baab1d1f0560fe" title="Retrieves the raw data chunk cache parameters.">H5Pget_chunk_cache</a> functions and then reset appropriate parameters if necessary. See the <a class="el" href="improve_compressed_perf.html#subsubsec_improve_compressed_perf_tune_cache_how">How to Adjust the Chunk Cache Size</a> section for more information.</p>
<p>The default size of the cache is 1MB. The size can be modified by setting the <b>nbytes</b> parameter in <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a>. Several chunks can be held in the cache if their total size in bytes is less or equal to 1MB.</p>
<p>To look up a chunk in cache, the HDF5 Library uses an array of pointers to the chunks (hash table). The array has <b>nslots</b> elements (or slots in the hash table) with a default value of 511. One can use the <b>nslots</b> parameter in <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> to change the default size of the hash table.</p>
<p>Each chunk has an associated hash value that is calculated as follows. All chunks of the dataset have an index (<b>cindex</b>) in a linear array of chunks. For example, chunks in Figure 9 will have indices from 0 to 5, with the upper left chunk having index 0, the middle one in the top row having index 1, and the lower right chunk having index 5. The hash value is calculated as the remainder of dividing <b>cindex</b> by <b>nslots</b> (known as a modulo operation <b>cindex mod nslots</b>). The hash table can contain only one chunk with the same hash value. This fact is important to remember to avoid situations when the needed chunks have the same hash value. For example, let’s assume <b>nslots</b> is 3. Then in Figure 9 the chunks with the indices 0 and 3 (in other words, the chunks that contain the first three columns) have the same hash values and cannot be in the chunk cache simultaneously even though their total sizes are less than 1MB.</p>
<p>Now, we can analyze what happens when data is read by “rows” (contiguous 717 elements) from the <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> dataset and the default chunk cache settings are used. The number of slots <b>nslots</b> in the hash table is not a concern since the default value is 511 and we have only 15 chunks. Now let’s analyze how the chunk cache size affects the performance.</p>
<p>Each row is stored in one of the 15 chunks that comprise the dataset. Each chunk has 4x30x9 or 1,080 “rows”. To read the first row of the chunk, the whole chunk is read, uncompressed and the row is copied to the application buffer by the HDF5 Library. Since the size of the uncompressed chunk is 2.95 MB, the cache cannot hold the chunk. When the second row is read, the process repeats until all rows from the same chunk are read. Thus, the chunk will be read and uncompressed 1,080 times. When we increase the cache size to 3MB, the chunk stays in the cache and all rows can be copied to the application buffer without the HDF5 Library fetching data from disk and uncompressing the chunk every time the chunk is accessed.</p>
<p>Since all 15 chunks have to be read, the HDF5 Library will be touching the disk 16,200 times when a 1MB size cache is used compared with 15 times when a 3MB cache is used. The first column in Table 5 below shows that it took 345 seconds to read a compressed dataset when using the default cache size of 1MB while it took only 0.37 seconds to read the dataset when using the chunk cache size of 3MB. We see several orders of magnitude performance improvements when we increase chunk cache size to 3MB. </p><table class="doxtable">
<caption>Table 5: Performance improved when the chunk cache size was adjusted to 3MB by several orders of magnitude.</caption>
<tr>
<th>File Name</th><td>File_with_compression.h5</td><td>File_with_compression.h5 </td></tr>
<tr>
<th>Cache Size</th><td>1MB (default)</td><td>3MB </td></tr>
<tr>
<th>Read Time</th><td>345 seconds</td><td>0.37 seconds </td></tr>
</table>
<p>As shown in Table 6 below, the reading performance with the 3MB cache size is comparable to the reading performance of the data stored without compression applied. Please notice that the chunk cache size did not affect the reading performance for the uncompressed data. </p><table class="doxtable">
<caption>Table 6: With the chunk cache size adjusted to 3MB, performance is comparable with the performance of reading data that was stored without compression.</caption>
<tr>
<th>File Name</th><td>File_with_compression.h5</td><td>File.h5 </td></tr>
<tr>
<th>Cache Size</th><td>3MB</td><td>1MB or 3MB </td></tr>
<tr>
<th>Read Time</th><td>0.37 seconds</td><td>0.1 seconds </td></tr>
</table>
<ul>
<li>Note that the read times in the tables above are approximate values.</li>
</ul>
<h3><a class="anchor" id="subsubsec_improve_compressed_perf_tune_cache_how"></a>
How to Adjust the Chunk Cache Size</h3>
<p>As was mentioned above, an application can adjust the chunk cache size by calling either <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> or <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> functions. <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> sets the chunk cache size for all chunked datasets in a file, and <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> sets the chunk cache size for a particular dataset.</p>
<p>The programming model for using both functions is the following: </p><ul>
<li>Use <a class="el" href="group___f_a_p_l.html#ga9481a0b08d729ec68897d57db1827861" title="Queries the raw data chunk cache parameters.">H5Pget_cache</a> or <a class="el" href="group___d_a_p_l.html#gaeda015dfee4167cc60baab1d1f0560fe" title="Retrieves the raw data chunk cache parameters.">H5Pget_chunk_cache</a> to retrieve the default parameters set by the library or by a previous call to the function. </li>
<li>Use <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> or <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> to modify a subset of the parameters.</li>
</ul>
<p>Below are the code snippets that show the usage.</p>
<p>The first example below shows how to change the cache size for all datasets in the file using <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a>. Since the function sets a global setting for the file, it uses a file access property list identifier to modify the cache size. <a class="el" href="group___f_a_p_l.html#ga9481a0b08d729ec68897d57db1827861" title="Queries the raw data chunk cache parameters.">H5Pget_cache</a> is called first to retrieve default cache settings that will be modified by <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a>. In the example below, every chunked dataset will have a cache size of 3MB. To overwrite this setting for a particular dataset one can use <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a> as shown in the second example. </p><table class="doxtable">
<tr>
<th>Code Example 1: Using H5Pset_cache to change the cache size for all datasets. </th></tr>
</table>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl;    <span class="comment">// File access property identifier</span></div>
<div class="line"><span class="keywordtype">int</span> nelemts;   <span class="comment">// Dummy parameter in API, no longer used</span></div>
<div class="line"><span class="keywordtype">size_t</span> nslots; <span class="comment">// Number of slots in the hash table</span></div>
<div class="line"><span class="keywordtype">size_t</span> nbytes; <span class="comment">// Size of chunk cache in bytes</span></div>
<div class="line"><span class="keywordtype">double</span> w0;     <span class="comment">// Chunk preemption policy</span></div>
<div class="line">……</div>
<div class="line">fapl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a> (<a class="code hl_define" href="_h5_ppublic_8h.html#a60ec2d4334addfc0eda89614598ee38e">H5P_FILE_ACCESS</a>);</div>
<div class="line"><span class="comment">// Retrieve default cache parameters</span></div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga9481a0b08d729ec68897d57db1827861">H5Pget_cache</a>(fapl, &amp;nelemts, &amp;nslots, &amp;nbytes, &amp;w0)</div>
<div class="line"><span class="comment">// Set cache size to 3MBs and instruct the cache to discard the fully read chunk</span></div>
<div class="line">nbytes = 3 * 1024 * 1024;</div>
<div class="line">w0 = 1.</div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89">H5Pset_cache</a>(fapl, nelemts, nslots, nbytes, w0);</div>
<div class="line">fid = <a class="code hl_function" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc">H5Fopen</a> (file, <a class="code hl_define" href="_h5_fpublic_8h.html#a1c406ffa89f4acf5a332144a2683d394">H5F_ACC_RDONLY</a>, fapl);</div>
<div class="line"><a class="code hl_function" href="group___h5_d.html#ga04198c4cf0b849ed3a8921f6c7169ee2">H5Dopen2</a> (fid, “/All_Data/CrIS-SDR_All/ES_ImaginaryLW”, H5P_DEAFULT);</div>
<div class="line">……</div>
<div class="ttc" id="a_h5_fpublic_8h_html_a1c406ffa89f4acf5a332144a2683d394"><div class="ttname"><a href="_h5_fpublic_8h.html#a1c406ffa89f4acf5a332144a2683d394">H5F_ACC_RDONLY</a></div><div class="ttdeci">#define H5F_ACC_RDONLY</div><div class="ttdef"><b>Definition</b> H5Fpublic.h:48</div></div>
<div class="ttc" id="a_h5_ipublic_8h_html_a0045db7ff9c22ad35db6ae91662e1943"><div class="ttname"><a href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a></div><div class="ttdeci">int64_t hid_t</div><div class="ttdef"><b>Definition</b> H5Ipublic.h:60</div></div>
<div class="ttc" id="a_h5_ppublic_8h_html_a60ec2d4334addfc0eda89614598ee38e"><div class="ttname"><a href="_h5_ppublic_8h.html#a60ec2d4334addfc0eda89614598ee38e">H5P_FILE_ACCESS</a></div><div class="ttdeci">#define H5P_FILE_ACCESS</div><div class="ttdef"><b>Definition</b> H5Ppublic.h:64</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga034a5fc54d9b05296555544d8dd9fe89"><div class="ttname"><a href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89">H5Pset_cache</a></div><div class="ttdeci">herr_t H5Pset_cache(hid_t plist_id, int mdc_nelmts, size_t rdcc_nslots, size_t rdcc_nbytes, double rdcc_w0)</div><div class="ttdoc">Sets the raw data chunk cache parameters.</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga9481a0b08d729ec68897d57db1827861"><div class="ttname"><a href="group___f_a_p_l.html#ga9481a0b08d729ec68897d57db1827861">H5Pget_cache</a></div><div class="ttdeci">herr_t H5Pget_cache(hid_t plist_id, int *mdc_nelmts, size_t *rdcc_nslots, size_t *rdcc_nbytes, double *rdcc_w0)</div><div class="ttdoc">Queries the raw data chunk cache parameters.</div></div>
<div class="ttc" id="agroup___h5_d_html_ga04198c4cf0b849ed3a8921f6c7169ee2"><div class="ttname"><a href="group___h5_d.html#ga04198c4cf0b849ed3a8921f6c7169ee2">H5Dopen2</a></div><div class="ttdeci">hid_t H5Dopen2(hid_t loc_id, const char *name, hid_t dapl_id)</div><div class="ttdoc">Opens an existing dataset.</div></div>
<div class="ttc" id="agroup___h5_f_html_gaa3f4f877b9bb591f3880423ed2bf44bc"><div class="ttname"><a href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc">H5Fopen</a></div><div class="ttdeci">hid_t H5Fopen(const char *filename, unsigned flags, hid_t fapl_id)</div><div class="ttdoc">Opens an existing HDF5 file.</div></div>
<div class="ttc" id="agroup___p_l_c_r_html_gaf1b11da01d4d45d788c45f8bc5f0cbfa"><div class="ttname"><a href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a></div><div class="ttdeci">hid_t H5Pcreate(hid_t cls_id)</div><div class="ttdoc">Creates a new property list as an instance of a property list class.</div></div>
</div><!-- fragment --><p>The second example, see below, shows how to set at dataset creation time the chunk cache size for the <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> dataset. The cache sizes for other datasets will not be modified. </p><table class="doxtable">
<tr>
<th>Code Example 2 : Using H5Pset_chunk_cache to change one dataset. </th></tr>
</table>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> dapl;    <span class="comment">// File access property identifier</span></div>
<div class="line"><span class="keywordtype">size_t</span> nslots; <span class="comment">// Number of slots in the hash table</span></div>
<div class="line"><span class="keywordtype">size_t</span> nbytes; <span class="comment">// Size of chunk cache in bytes</span></div>
<div class="line"><span class="keywordtype">double</span> w0;     <span class="comment">// Chunk preemption policy</span></div>
<div class="line">……</div>
<div class="line">dapl = <a class="code hl_function" href="group___p_l_c_r.html#gaf1b11da01d4d45d788c45f8bc5f0cbfa">H5Pcreate</a> (<a class="code hl_define" href="_h5_ppublic_8h.html#afd849c0834c8ce6580b7c2537dbd9b5d">H5P_DATASET_ACCESS</a>);</div>
<div class="line"><span class="comment">// Retrieve default cache parameters</span></div>
<div class="line"><a class="code hl_function" href="group___d_a_p_l.html#gaeda015dfee4167cc60baab1d1f0560fe">H5Pget_chunk_cache</a>(dapl, &amp;nslots, &amp;nbytes, &amp;w0)</div>
<div class="line"><span class="comment">// Set cache size to 3MBs and instruct the cache to discard the fully read chunk</span></div>
<div class="line">nbytes = 3 * 1024 * 1024;</div>
<div class="line">w0 = 1.</div>
<div class="line"><a class="code hl_function" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1">H5Pset_chunk_cache</a>(dapl, nslots, nbytes, w0);</div>
<div class="line"><a class="code hl_function" href="group___h5_d.html#ga04198c4cf0b849ed3a8921f6c7169ee2">H5Dopen2</a> (fid, “/All_Data/CrIS-SDR_All/ES_ImaginaryLW”, dapl);</div>
<div class="line">……</div>
<div class="ttc" id="a_h5_ppublic_8h_html_afd849c0834c8ce6580b7c2537dbd9b5d"><div class="ttname"><a href="_h5_ppublic_8h.html#afd849c0834c8ce6580b7c2537dbd9b5d">H5P_DATASET_ACCESS</a></div><div class="ttdeci">#define H5P_DATASET_ACCESS</div><div class="ttdef"><b>Definition</b> H5Ppublic.h:72</div></div>
<div class="ttc" id="agroup___d_a_p_l_html_ga104d00442c31714ee073dee518f661f1"><div class="ttname"><a href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1">H5Pset_chunk_cache</a></div><div class="ttdeci">herr_t H5Pset_chunk_cache(hid_t dapl_id, size_t rdcc_nslots, size_t rdcc_nbytes, double rdcc_w0)</div><div class="ttdoc">Sets the raw data chunk cache parameters.</div></div>
<div class="ttc" id="agroup___d_a_p_l_html_gaeda015dfee4167cc60baab1d1f0560fe"><div class="ttname"><a href="group___d_a_p_l.html#gaeda015dfee4167cc60baab1d1f0560fe">H5Pget_chunk_cache</a></div><div class="ttdeci">herr_t H5Pget_chunk_cache(hid_t dapl_id, size_t *rdcc_nslots, size_t *rdcc_nbytes, double *rdcc_w0)</div><div class="ttdoc">Retrieves the raw data chunk cache parameters.</div></div>
</div><!-- fragment --><p> As we will see in the next section, care needs to be taken when working with chunked datasets and setting chunk cache sizes: an application’s memory footprint can be significantly affected.</p>
<h3><a class="anchor" id="subsubsec_improve_compressed_perf_tune_cache_mem"></a>
Chunk Cache Size and Application Memory</h3>
<p>A chunk cache is allocated for a dataset when the first I/O operation is performed. The chunk cache is discarded after the dataset is closed. If an application performs I/O on several datasets, memory consumed by an application increases by the total size of all chunk caches. One can also see an increase in the metadata cache size.</p>
<p>If memory consumption is a concern, it is recommended that I/O be done on a few datasets at a time and to close the few datasets after I/O operation has been completed. As we will see in the next sections, there are access patterns that cannot take advantage of a chunk cache at all. If this is the case, the application can disable a chunk cache completely and thus reduce the memory footprint. To disable a chunk cache, use 0 for the value of the <b>nbytes</b> parameter in the calls to <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a> or <a class="el" href="group___d_a_p_l.html#ga104d00442c31714ee073dee518f661f1" title="Sets the raw data chunk cache parameters.">H5Pset_chunk_cache</a>.</p>
<h2><a class="anchor" id="subsec_improve_compressed_perf_tune_access"></a>
Change the Access Pattern</h2>
<p>When changing the chunk cache size is not an option (for example, there is no access to the program source code), one can consider a reading strategy that will minimize the effect of the chunk cache size. The strategy is to read as much data as possible in each read operation.</p>
<p>As we mentioned before, the HDF5 Library performs I/O on the whole chunk. The chunk is read, uncompressed, and the requested data is copied to the application buffer. If in one read call the application requests all data in a chunk, then obviously chunk caching (and chunk cache size) is irrelevant since there is no need to access the same chunk again.</p>
<p>In our case, suppose the application reads the selection that corresponds to the whole chunk. In other words, if a hyperslab with dimensions 4x30x9x717 is used instead of a hyperslab with dimensions 1x1x1x717, then the HDF5 Library would perform only 15 reading and decoding operations instead of 16,200. The significant improvement in performance is shown in Table 7 below. We see a similar I/O performance improvement as in the case when we increased the chunk cache size to 3MB (see Table 5).</p>
<table class="doxtable">
<caption>Table 7: Leaving the chunk cache size unchanged and changing the access pattern to read more data improves performance by several orders of magnitude.</caption>
<tr>
<th>File Name</th><td>File_with_compression.h5</td><td>File_with_compression.h5 </td></tr>
<tr>
<th>Access Pattern</th><td>1x1x1x717</td><td>4x30x9x717 </td></tr>
<tr>
<th>Read Time</th><td>345 seconds</td><td>0.36 seconds </td></tr>
</table>
<ul>
<li>Note that the read times in the table above are approximate values.</li>
</ul>
<h2><a class="anchor" id="subsec_improve_compressed_perf_tune_size"></a>
Change the Chunk Size</h2>
<p>Data producers should consider that users who cannot modify applications to increase the chunk cache size or to change the access pattern will not encounter the performance problem described in the <a class="el" href="improve_compressed_perf.html#subsubsec_improve_compressed_perf_tune_cache_how">How to Adjust the Chunk Cache Size</a> section if chunks in the file are smaller than 1MB (1x30x9x717 by 4 bytes) because the whole chunk will fit into the chunk cache of the default size. Therefore if data in the HDF5 files is intended for reading by unknown user applications or on systems that might be different from the system where it was written, it is a good idea to consider a chunk size less than 1MB. In this case the applications that use default HDF5 settings will not be penalized.</p>
<p>As shown in the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_case">Case Study</a> section, Table 4, the performance of reading by row (717 elements) when the chunk size is 1x30x9x717 (total size in bytes is approximately 0.74MB) is comparable to the performance of reading non-compressed data and is similar to the performance for reading compressed data when using a bigger cache size (Table 2) or bigger amount of data (Table 3). The above statement is summarized in the <a class="el" href="improve_compressed_perf.html#sec_improve_compressed_perf_rec">Recommendations</a> section.</p>
<p>For users who encounter datasets with large chunk sizes and with applications that cannot be easily modified: since the chunk size is set at the dataset creation time and cannot be changed later, the only option is to recreate the dataset by using the <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> tool to change the storage layout properties. The command below will change the chunk size of the <code>/All_Data/CrIS-SDR_All/ES_ImaginaryLW</code> dataset from 4x30x9x717 to 1x30x9x717 making chunk size in bytes 0.74MB instead of the original 2.96MBs size. </p><div class="fragment"><div class="line">% <a class="code hl_function" href="h5repack_8h.html#a314b5651a0aa5175d64605dbc83e094e">h5repack</a> -l /All_Data/CrIS-SDR_All/ES_ImaginaryLW:<a class="code hl_define" href="h5import_8h.html#a25022864dfc8ec428e7128282e57b136">CHUNK</a>=1x30x9x717</div>
<div class="line">  gz6_SCRIS_npp_d20140522_t0754579_e0802557_b13293__noaa_pop.h5 <span class="keyword">new</span>.h5</div>
<div class="ttc" id="ah5import_8h_html_a25022864dfc8ec428e7128282e57b136"><div class="ttname"><a href="h5import_8h.html#a25022864dfc8ec428e7128282e57b136">CHUNK</a></div><div class="ttdeci">#define CHUNK</div><div class="ttdef"><b>Definition</b> h5import.h:341</div></div>
<div class="ttc" id="ah5repack_8h_html_a314b5651a0aa5175d64605dbc83e094e"><div class="ttname"><a href="h5repack_8h.html#a314b5651a0aa5175d64605dbc83e094e">h5repack</a></div><div class="ttdeci">int h5repack(const char *infile, const char *outfile, pack_opt_t *options)</div></div>
</div><!-- fragment --><h1><a class="anchor" id="sec_improve_compressed_perf_rec"></a>
Recommendations</h1>
<p>This section summarizes the discussion and recommendations for working with files that use the HDF5 chunking and compression feature.</p>
<p>When compression is enabled for an HDF5 dataset, the library must always read an entire chunk for each call to <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> unless the chunk is already in the cache. To avoid trashing the cache, make sure that the chunk cache size is big enough to hold the whole chunk or that the application reads the whole chunk in one read operation bypassing the chunk cache.</p>
<p>When experiencing I/O performance problems with compressed data, find the size of the chunk and try the strategy that is most applicable to your use case: </p><ul>
<li>Increase the size of the chunk cache to hold the whole chunk. </li>
<li>Increase the amount of the selected data to read (making selection to be the whole chunk will guarantee bypassing the chunk cache). </li>
<li>Decrease the chunk size by using <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> tool to fit into the default size chunk cache.</li>
</ul>
<p>The results of all three strategies provide similar performance and are summarized in Table 8 below. </p><table class="doxtable">
<caption>Table 8: By varying different parameters (highlighted) one can achieve good I/O performance for reading compressed data.</caption>
<tr>
<th>File Name </th><td>File_with_compression.h5 </td><td>File_with_compression.h5 </td><td>File_with_compression.h5 </td><td>File_with_compression-small-chunk.h5 </td></tr>
<tr>
<th>Cache Size </th><td>1MB </td><td>3MB </td><td>1MB </td><td>1MB </td></tr>
<tr>
<th>Chunk Size </th><td>4x30x9x717 </td><td>4x30x9x717 </td><td>4x30x9x717 </td><td>1x30x9x717 </td></tr>
<tr>
<th>Access Pattern (Hyperslab Size) </th><td>1x1x1x717 </td><td>1x1x1x717 </td><td>4x30x9x717 </td><td>1x1x1x717 </td></tr>
<tr>
<th>Read Time </th><td>345 seconds </td><td>0.37 seconds </td><td>0.36 seconds </td><td>0.36 seconds </td></tr>
<tr>
<th>Repack Time </th><td>NA </td><td>NA </td><td>NA </td><td>12 seconds </td></tr>
</table>
<ul>
<li>Note that the read and repack times in the table above are approximate values.</li>
</ul>
<p>Please notice that when compression is disabled, the library’s behavior depends on the cache size relative to the chunk size. If the chunk fits the cache, the library reads entire chunk for each call to <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> unless it is in cache already. If the chunk doesn’t fit the cache, the library reads only the data that is selected directly from the file. There will be more read operations, especially if the read plane does not include the fastest changing dimension.</p>
<p>One can use <a class="el" href="_h5_t_o_o_l__r_p__u_g.html#sec_cltools_h5repack">h5repack</a> tool to remove compression by using the following command: </p><div class="fragment"><div class="line">% <a class="code hl_function" href="h5repack_8h.html#a314b5651a0aa5175d64605dbc83e094e">h5repack</a> -f /All_Data/CrIS-SDR_All/ES_ImaginaryLW:NONE</div>
<div class="line">  gz6_SCRIS_npp_d20140522_t0754579_e0802557_b13293__noaa_pop.h5 <span class="keyword">new</span>.h5</div>
</div><!-- fragment --><p>The CCP tool described in the introduction is intended to facilitate optimization of the parameters chosen when creating files and investigation of possible solutions when performance problems are encountered. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
