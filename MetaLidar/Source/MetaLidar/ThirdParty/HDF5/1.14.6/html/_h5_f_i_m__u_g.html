<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: HDF5 File Image</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better serve our user community by answering the following short survey:  <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;1.14.6</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_f_t_s.html"><span>Full-Text&#160;Search</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('_h5_f_i_m__u_g.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">HDF5 File Image</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_file_image"></a>
HDF5 File Image</h1>
<h2><a class="anchor" id="subsec_file_image_intro"></a>
Introduction to HDF5 File Image Operations</h2>
<p>File image operations allow users to work with HDF5 files in memory in the same ways that users currently work with HDF5 files on disk. Disk I/O is not required when file images are opened, created, read from, or written to.</p>
<p>An HDF5 file image is an HDF5 file that is held in a buffer in main memory. Setting up a file image in memory involves using either a buffer in the file access property list or a buffer in the <a class="el" href="_h5_f__u_g.html#subsubsec_file_alternate_drivers_mem">The Memory (aka Core) Driver</a> file driver. The advantage of working with a file in memory is faster access to the data.</p>
<p>The challenge of working with files in memory buffers is maximizing performance and minimizing memory footprint while working within the constraints of the property list mechanism. This should be a non-issue for small file images, but may be a major issue for large images.</p>
<p>If invoked with the appropriate flags, the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> high level library call should deal with these challenges in most cases. However, some applications may require the programmer to address these issues directly.</p>
<h3><a class="anchor" id="subsubsec_file_image_intro_sum"></a>
HDF5 File Image Operations Function Summary</h3>
<p>Functions used in file image operations are listed below. </p><table class="doxtable">
<caption>File image operations functions</caption>
<tr>
<th>C Function </th><th>Purpose  </th></tr>
<tr>
<td><a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> </td><td>Allows an application to specify an initial file image. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI211">FI211</a>.  </td></tr>
<tr>
<td><a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a> </td><td>Allows an application to retrieve a copy of the file image designated for a VFD to use as the initial contents of a file. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI212">FI212</a>.  </td></tr>
<tr>
<td><a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> </td><td>Allows an application to manage file image buffer allocation, copying, reallocation, and release. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI213">FI213</a>.  </td></tr>
<tr>
<td><a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a> </td><td>Allows an application to obtain the current file image callbacks from a file access property list. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI214">FI214</a>.  </td></tr>
<tr>
<td><a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> </td><td>Provides a simple way to retrieve a copy of the image of an existing, open file. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI216">FI216</a>.  </td></tr>
<tr>
<td><a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> </td><td>Provides a convenient way to open an initial file image with the Core VFD. For more information, see section <a class="el" href="_h5_f_i_m__u_g.html#FI221">FI221</a>.  </td></tr>
</table>
<h3><a class="anchor" id="subsubsec_file_image_intro_abbr"></a>
Abbreviations</h3>
<table class="doxtable">
<caption>Abbreviations</caption>
<tr>
<th>Abbreviation </th><th>This abbreviation is short for  </th></tr>
<tr>
<td>FAPL or fapl </td><td>File Access Property List. In code samples, fapl is used.  </td></tr>
<tr>
<td>VFD </td><td>Virtual File Driver  </td></tr>
<tr>
<td>VFL </td><td>Virtual File Layer  </td></tr>
</table>
<h3><a class="anchor" id="subsubsec_file_image_intro_pre"></a>
Developer Prerequisites</h3>
<p>Developers who use the file image operations described in this document should be proficient and experienced users of the HDF5 C Library APIs. More specifically, developers should have a working knowledge of property lists, callbacks, and virtual file drivers.</p>
<h3><a class="anchor" id="subsubsec_file_image_intro_res"></a>
Resources</h3>
<p>See the following for more information.</p>
<p>The <a class="el" href="_h5_f__u_g.html#subsec_file_alternate_drivers">Alternate File Storage Layouts and Low-level File Drivers</a> section is in <a class="el" href="_h5_f__u_g.html#sec_file">The HDF5 File</a> chapter of the <a class="el" href="_u_g.html">HDF5 User Guide</a>.</p>
<p>The <a class="el" href="group___f_a_p_l.html#ga6e6628f620a1c58c704129cf07282849" title="Modifies the file access property list to use the H5FD_CORE driver.">H5Pset_fapl_core</a> function call can be used to modify the file access property list so that the Memory virtual file driver, <a class="el" href="_h5_f_dcore_8h.html#ae449696f6b86abcd1120beab21fff76a">H5FD_CORE</a>, is used. The Memory file driver is also known as the Core file driver.</p>
<p>Links to the <a class="el" href="_v_f_l_t_n.html">HDF5 Virtual File Layer</a> and List of Functions documents can be found in the HDF5 <a class="el" href="_t_n.html">Technical Notes</a>.</p>
<h2><a class="anchor" id="subsec_file_image_api"></a>
File Image C API Call Syntax</h2>
<p>The C API function calls described in this chapter fall into two categories: low-level routines that are part of the main HDF5 C Library and one high-level routine that is part of the “lite” API in the high-level wrapper library. The high-level routine uses the low-level routines and presents frequently requested functionality conveniently packaged for application developers’ use.</p>
<h3><a class="anchor" id="subsubsec_file_image_api_low"></a>
Low-level C API Routines</h3>
<p>The purpose of this section is to describe the low-level C API routines that support file image operations. These routines allow an in-memory image of an HDF5 file to be opened without requiring file system I/O.</p>
<p>The basic approach to opening an in-memory image of an HDF5 file is to pass the image to the Core file driver, and then tell the Core file driver to open the file. We do this by using the <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a>/<a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> calls. These calls allow the user to specify an initial file image.</p>
<p>A potential problem with the <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a>/<a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> calls is the overhead of allocating and copying of large file image buffers. The callback routines enable application programs to avoid this problem. However, the use of these callbacks is complex and potentially hazardous: the particulars are discussed in the semantics and examples chapters below (see section <a class="el" href="_h5_f_i_m__u_g.html#subsubsec_file_image_semantics_cbk">File Image Callback Semantics</a> and section <a class="el" href="_h5_f_i_m__u_g.html#subsubsec_file_image_example_read">Reading an In-memory HDF5 File Image</a> respectively). Fortunately, use of the file image callbacks should seldom be necessary: the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> call should address most use cases.</p>
<p>The property list facility in HDF5 is employed in file image operations. This facility was designed for passing data, not consumable resources, into API calls. The peculiar ways in which the file image allocation callbacks may be used allows us to avoid extending the property list structure to handle consumable resources cleanly and to avoid constructing a new facility for the purpose.</p>
<p>The sub-sections below describe the low-level C APIs that are used with file image operations.</p>
<p><a class="anchor" id="FI211"></a></p><h4><a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a></h4>
<p>The <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> routine allows an application to provide an image for a file driver to use as the initial contents of the file. This call was designed initially for use with the Core VFD, but it can be used with any VFD that supports using an initial file image when opening a file. See the <a class="el" href="_h5_f_i_m__u_g.html#FI215">FI215</a> section for more information. Calling this routine makes a copy of the provided file image buffer. See the <a class="el" href="_h5_f_i_m__u_g.html#FI213">FI213</a> section for more information.</p>
<p>The signature of <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> is defined as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> <a class="code hl_function" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a>(<a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl_id, <span class="keywordtype">void</span> *buf_ptr, <span class="keywordtype">size_t</span> buf_len)</div>
<div class="ttc" id="a_h5_ipublic_8h_html_a0045db7ff9c22ad35db6ae91662e1943"><div class="ttname"><a href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a></div><div class="ttdeci">int64_t hid_t</div><div class="ttdef"><b>Definition</b> H5Ipublic.h:60</div></div>
<div class="ttc" id="a_h5public_8h_html_a3b079ecf932a5c599499cf7e298af160"><div class="ttname"><a href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a></div><div class="ttdeci">int herr_t</div><div class="ttdef"><b>Definition</b> H5public.h:239</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga31d0299f6ad287e013b2a02a8ccc1fa2"><div class="ttname"><a href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a></div><div class="ttdeci">herr_t H5Pset_file_image(hid_t fapl_id, void *buf_ptr, size_t buf_len)</div><div class="ttdoc">Sets an initial file image in a memory buffer.</div></div>
</div><!-- fragment --><p>The parameters of <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> are defined as follows: </p><ul>
<li>fapl_id contains the ID of the target file access property list. </li>
<li>buf_ptr supplies a pointer to the initial file image, or NULL if no initial file image is desired. </li>
<li>buf_len contains the size of the supplied buffer, or 0 if no initial image is desired. If either the buf_len parameter is zero, or the buf_ptr parameter is NULL, no file image will be set in the FAPL, and any existing file image buffer in the FAPL will be released. If a buffer is released, the FAPL’s file image buf_len will be set to 0 and buf_ptr will be set to NULL.</li>
</ul>
<p>Given the tight interaction between the file image callbacks and the file image, the file image callbacks in a property list cannot be changed while a file image is defined.</p>
<p>With properly constructed file image callbacks, it is possible to avoid actually copying the file image. The particulars of this are discussed in greater detail in the <a class="el" href="_h5_f_i_m__u_g.html#subsec_file_image_semantics">C API Call Semantics</a> chapter and in the <a class="el" href="_h5_f_i_m__u_g.html#subsec_file_image_example">Examples</a> chapter.</p>
<p><a class="anchor" id="FI212"></a></p><h4><a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a></h4>
<p>The <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a> routine allows an application to retrieve a copy of the file image designated for a VFD to use as the initial contents of a file. This routine uses the file image callbacks (if defined) when allocating and loading the buffer to return to the application, or it uses malloc and memcpy if the callbacks are undefined. When malloc and memcpy are used, it will be the caller’s responsibility to discard the returned buffer via a call to free.</p>
<p>The signature of <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a> is defined as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> <a class="code hl_function" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b">H5Pget_file_image</a>(<a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl_id, <span class="keywordtype">void</span> **buf_ptr_ptr, <span class="keywordtype">size_t</span> *buf_len_ptr)</div>
<div class="ttc" id="agroup___f_a_p_l_html_ga337626cc516d5d1e3303ea6bc350e56b"><div class="ttname"><a href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b">H5Pget_file_image</a></div><div class="ttdeci">herr_t H5Pget_file_image(hid_t fapl_id, void **buf_ptr_ptr, size_t *buf_len_ptr)</div><div class="ttdoc">Retrieves a copy of the file image designated as the initial content and structure of a file.</div></div>
</div><!-- fragment --><p>The parameters of <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a> are defined as follows: </p><ul>
<li>fapl_id contains the ID of the target file access property list. </li>
<li>buf_ptr_ptr contains a NULL or a pointer to a void*. If buf_ptr_ptr is not NULL, on successful return, *buf_ptr_ptr will contain a pointer to a copy of the initial image provided in the last call to <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> for the supplied fapl_id. If no initial image has been set, *buf_ptr_ptr will be NULL. </li>
<li>buf_len_ptr contains a NULL or a pointer to size_t. If buf_len_ptr is not NULL, on successful return, *buf_len_ptr will contain the value of the buf_len parameter for the initial image in the supplied fapl_id. If no initial image is set, the value of *buf_len_ptr will be 0. As with <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a>, appropriately defined file image callbacks can allow this function to avoid buffer allocation and memory copy operations.</li>
</ul>
<p><a class="anchor" id="FI213"></a></p><h4><a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a></h4>
<p>The <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> API call exists to allow an application to control the management of file image buffers through user defined callbacks. These callbacks will be used in the management of file image buffers in property lists and in select file drivers. These routines are invoked when a new file image buffer is allocated, when an existing file image buffer is copied or resized, or when a file image buffer is released from use. From the perspective of the HDF5 Library, the operations of the image_malloc, image_memcpy, image_realloc, and image_free callbacks must be identical to those of the corresponding C standard library calls (malloc, memcpy, realloc, and free). While the operations must be identical, the file image callbacks have more parameters. The callbacks and their parameters are described below. The return values of image_malloc and image_realloc are identical to the return values of malloc and realloc. However, the return values of image_memcpy and image_free are different than the return values of memcpy and free: the return values of image_memcpy and image_free can also indicate failure. See the <a class="el" href="_h5_f_i_m__u_g.html#subsec_file_image_semantics">C API Call Semantics</a> section for more information.</p>
<p>The signature of <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> is defined as follows: </p><div class="fragment"><div class="line">    <span class="keyword">typedef</span> <span class="keyword">enum</span> { <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</a>, <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</a>,</div>
<div class="line"><a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</a>, <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a>, <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc">H5FD_FILE_IMAGE_OP_FILE_OPEN</a>,</div>
<div class="line"><a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda5f979f4e4af545e6aba40f9b2af14caf">H5FD_FILE_IMAGE_OP_FILE_RESIZE</a>, <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a> } <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">        <span class="keywordtype">void</span> *(*image_malloc)(<span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata);</div>
<div class="line">        <span class="keywordtype">void</span> *(*image_memcpy)(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op,</div>
<div class="line"><span class="keywordtype">void</span> *udata); <span class="keywordtype">void</span> *(*image_realloc)(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span></div>
<div class="line">*udata); <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> (*image_free)(<span class="keywordtype">void</span> *ptr, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata); <span class="keywordtype">void</span></div>
<div class="line">*(*udata_copy)(<span class="keywordtype">void</span> *udata); <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> (*udata_free)(<span class="keywordtype">void</span> *udata); <span class="keywordtype">void</span> *udata; } <a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a>;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> <a class="code hl_function" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a>(<a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl_id, <a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> *callbacks_ptr)</div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dd"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a></div><div class="ttdeci">H5FD_file_image_op_t</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:282</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:294</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc">H5FD_FILE_IMAGE_OP_FILE_OPEN</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_FILE_OPEN</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:297</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dda5f979f4e4af545e6aba40f9b2af14caf"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda5f979f4e4af545e6aba40f9b2af14caf">H5FD_FILE_IMAGE_OP_FILE_RESIZE</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_FILE_RESIZE</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:305</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:291</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_FILE_CLOSE</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:308</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:288</div></div>
<div class="ttc" id="a_h5_f_dpublic_8h_html_aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123"><div class="ttname"><a href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</a></div><div class="ttdeci">@ H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</div><div class="ttdef"><b>Definition</b> H5FDpublic.h:284</div></div>
<div class="ttc" id="agroup___f_a_p_l_html_ga14ea3598215afd078b964b672b40d63c"><div class="ttname"><a href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a></div><div class="ttdeci">herr_t H5Pset_file_image_callbacks(hid_t fapl_id, H5FD_file_image_callbacks_t *callbacks_ptr)</div><div class="ttdoc">Sets the callbacks for working with file images.</div></div>
<div class="ttc" id="astruct_h5_f_d__file__image__callbacks__t_html"><div class="ttname"><a href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a></div><div class="ttdef"><b>Definition</b> H5FDpublic.h:318</div></div>
</div><!-- fragment --><p>The parameters of <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> are defined as follows: </p><ul>
<li>fapl_id contains the ID of the target file access property list. </li>
<li>callbacks_ptr contains a pointer to an instance of the <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> structure.</li>
</ul>
<p>The fields of the <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> structure are defined as follows: </p><ul>
<li>image_malloc contains a pointer to a function with (from the perspective of HDF5) functionality identical to the standard C library malloc() call. The parameters of the image_malloc callback are defined as follows: <ul>
<li>
size contains the size in bytes of the image buffer to allocate. </li>
<li>
file_image_op contains one of the values of <a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a>. These values indicate the operation being performed on the file image when this callback is invoked. Possible values for file_image_op are discussed in <a class="el" href="_h5_f_i_m__u_g.html#FITable2">FITable2</a>. </li>
<li>
udata holds the value passed in for the udata parameter to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a>. Setting image_malloc to NULL indicates that the HDF5 Library should invoke the standard C library malloc() routine when allocating file image buffers. </li>
</ul>
</li>
<li>image_memcpy contains a pointer to a function with (from the perspective of HDF5) functionality identical to the standard C library memcpy() call except that it returns NULL on failure. Recall that the memcpy C Library routine is defined to return the dest parameter in all cases. The parameters of the image_memcpy callback are defined as follows: <ul>
<li>
dest contains the address of the destination buffer. </li>
<li>
src contains the address of the source buffer. </li>
<li>
size contains the number of bytes to copy. </li>
<li>
file_image_op contains one of the values of <a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a>. These values indicate the operation being performed on the file image when this callback is invoked. Possible values for file_image_op are discussed in <a class="el" href="_h5_f_i_m__u_g.html#FITable2">FITable2</a>. </li>
<li>
udata holds the value passed in for the udata parameter to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a>. Setting image_memcpy to NULL indicates that the HDF5 Library should invoke the standard C library memcpy() routine when copying buffers. </li>
</ul>
</li>
<li>image_realloc contains a pointer to a function with (from the perspective of HDF5) functionality identical to the standard C library realloc() call. The parameters of the image_realloc callback are defined as follows: <ul>
<li>
ptr contains the pointer to the buffer being reallocated. </li>
<li>
size contains the desired size in bytes of the buffer after realloc. </li>
<li>
file_image_op contains one of the values of H5FD_file_image_op_t. These values indicate the operation being performed on the file image when this callback is invoked. Possible values for file_image_op are discussed in <a class="el" href="_h5_f_i_m__u_g.html#FITable2">FITable2</a>. </li>
<li>
udata holds the value passed in for the udata parameter to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a>. Setting image_realloc to NULL indicates that the HDF5 Library should invoke the standard C library realloc() routine when resizing file image buffers. </li>
</ul>
</li>
<li>image_free contains a pointer to a function with (from the perspective of HDF5) functionality identical to the standard C library free() call except that it will return 0 (SUCCEED) on success and -1 (FAIL) on failure. The parameters of the image_free callback are defined as follows: <ul>
<li>
ptr contains the pointer to the buffer being released. </li>
<li>
file_image_op contains one of the values of H5FD_file_image_op_t. These values indicate the operation being performed on the file image when this callback is invoked. Possible values for file_image_op are discussed in <a class="el" href="_h5_f_i_m__u_g.html#FITable2">FITable2</a>. </li>
<li>
udata holds the value passed in for the udata parameter to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a>. Setting image_free to NULL indicates that the HDF5 Library should invoke the standard C library free() routine when releasing file image buffers. </li>
</ul>
</li>
<li>udata_copy contains a pointer to a function that (from the perspective of HDF5) allocates a buffer of suitable size, copies the contents of the supplied udata into the new buffer, and returns the address of the new buffer. The function returns NULL on failure. This function is necessary if a non-NULL udata parameter is supplied, so that property lists containing the image callbacks can be copied. If the udata parameter (below) is NULL, then this parameter should be NULL as well. The parameter of the udata_copy callback is defined as follows: <ul>
<li>
udata contains the pointer to the user data block being copied. </li>
<li>
udata_free contains a pointer to a function that (from the perspective of HDF5) frees a user data block. This function is necessary if a non-NULL udata parameter is supplied so that property lists containing image callbacks can be discarded without a memory leak. If the udata parameter (below) is NULL, this parameter should be NULL as well. The parameter of the udata_free callback is defined as follows: <ul>
<li>
udata contains the pointer to the user data block to be freed.  </li>
<li>
udata_free returns 0 (SUCCEED) on success and -1 (FAIL) on failure. </li>
</ul>
</li>
</ul>
</li>
<li>udata contains a pointer value, potentially to user-defined data, that will be passed to the image_malloc, image_memcpy, image_realloc, and image_free callbacks. The semantics of the values that can be set for the file_image_op parameter to the above callbacks are described in the table below: <a class="anchor" id="FITable2"></a>
<table class="doxtable">
<caption>Values for the file_image_op parameter</caption>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</a></td><td>This value is passed to the image_malloc and image_memcpy callbacks when an image buffer is being copied while being set in a FAPL.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</a></td><td>This value is passed to the image_malloc and image_memcpy callbacks when an image buffer is being copied when a FAPL is copied.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</a></td><td>This value is passed to the image_malloc and image_memcpy callbacks when an image buffer is being copied while being retrieved from a FAPL.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a></td><td>This value is passed to the image_free callback when an image buffer is being released during a FAPL close operation.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc">H5FD_FILE_IMAGE_OP_FILE_OPEN</a></td><td>This value is passed to the image_malloc and image_memcpy callbacks when an image buffer is copied during a file open operation. While the image being opened will typically be copied from a FAPL, this need not always be the case. An example of an exception is when the Core file driver takes its initial image from a file.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda5f979f4e4af545e6aba40f9b2af14caf">H5FD_FILE_IMAGE_OP_FILE_RESIZE</a></td><td>This value is passed to the image_realloc callback when a file driver needs to resize an image buffer.  </td></tr>
<tr>
<td><a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a></td><td>This value is passed to the image_free callback when an image buffer is being released during a file close operation.  </td></tr>
</table>
</li>
</ul>
<p>In closing our discussion of <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a>, we note the interaction between this call and the <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a>/<a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> calls above: since the malloc, memcpy, and free callbacks defined in the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> are used by <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a>/<a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a>, <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> will fail if a file image is already set in the target property list.</p>
<p>For more information on writing the file image to disk, set the backing_store parameter. See the <a class="el" href="group___f_a_p_l.html#ga6e6628f620a1c58c704129cf07282849" title="Modifies the file access property list to use the H5FD_CORE driver.">H5Pset_fapl_core</a> entry in the <a class="el" href="_r_m.html">HDF5 Reference Manual</a>.</p>
<p><a class="anchor" id="FI214"></a></p><h4><a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a></h4>
<p>The <a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a> routine is designed to obtain the current file image callbacks from a file access property list.</p>
<p>The signature of <a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks()</a> is defined as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> <a class="code hl_function" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e">H5Pget_file_image_callbacks</a>(<a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> fapl_id, <a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> *callbacks_ptr)</div>
<div class="ttc" id="agroup___f_a_p_l_html_gae17e38082dfdbadd75c897f1e6a9096e"><div class="ttname"><a href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e">H5Pget_file_image_callbacks</a></div><div class="ttdeci">herr_t H5Pget_file_image_callbacks(hid_t fapl_id, H5FD_file_image_callbacks_t *callbacks_ptr)</div><div class="ttdoc">Retrieves callback routines for working with file images.</div></div>
</div><!-- fragment --><p> The parameters of <a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a> are defined as follows: </p><ul>
<li>fapl_id contains the ID of the target file access property list. </li>
<li>callbacks_ptr contains a pointer to an instance of the <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> structure. All fields should be initialized to NULL. See the <a class="el" href="_h5_f_i_m__u_g.html#subsubsec_file_image_semantics_cbk">File Image Callback Semantics</a> section for more information on the <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> structure.</li>
</ul>
<p>Upon successful return, the fields of callbacks_ptr shall contain values as defined below: </p><ul>
<li>callbacks_ptr-&gt;image_malloc will contain the pointer passed as the image_malloc field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt;image_memcpy will contain the pointer passed as the image_memcpy field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt;image_realloc will contain the pointer passed as the image_realloc field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt;image_free_ptr will contain the pointer passed as the image_free field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt;udata_copy will contain the pointer passed as the udata_copy field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt; udata_free will contain the pointer passed as the udata_free field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks()</a> for the specified FAPL, or NULL if there has been no such call. </li>
<li>callbacks_ptr-&gt;udata will contain the pointer passed as the udata field of the instance of <a class="el" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> pointed to by the callbacks_ptr parameter of the last call to <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> for the specified FAPL, or NULL if there has been no such call.</li>
</ul>
<p><a class="anchor" id="FI215"></a></p><h4>Virtual File Driver Feature Flags</h4>
<p>Implementation of the <a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a>/<a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> and <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a>/<a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> function calls requires a pair of virtual file driver feature flags. The flags are <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> and <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a>. Both of these are defined in <a class="el" href="_h5_f_dpublic_8h.html">H5FDpublic.h</a>.</p>
<p>The first flag, <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a>, allows a file driver to indicate whether or not it supports file images. A VFD that sets this flag when its ‘query’ callback is invoked indicates that the file image set in the FAPL will be used as the initial contents of a file. Support for setting an initial file image is designed primarily for use with the Core VFD. However, any VFD can indicate support for this feature by setting the flag and copying the image in an appropriate way for the VFD (possibly by writing the image to a file and then opening the file). However, such a VFD need not employ the file image after file open time. In such cases, the VFD will not make an in-memory copy of the file image and will not employ the file image callbacks.</p>
<p>File drivers that maintain a copy of the file in memory (only the Core file driver at present) can be constructed to use the initial image callbacks (if defined). Those that do must set the <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a> flag, the second flag, when their ‘query’ callbacks are invoked.</p>
<p>Thus file drivers that set the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag but not the <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a> flag may read the supplied image from the property list (if present) and use it to initialize the contents of the file. However, they will not discard the image when done, nor will they make any use of any file image callbacks (if defined).</p>
<p>If an initial file image appears in a file allocation property list that is used in an <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen()</a> call, and if the underlying file driver does not set the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag, then the open will fail.</p>
<p>If a driver sets both the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag and the <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a> flag, then that driver will allocate a buffer of the required size, copy the contents of the initial image buffer from the file access property list, and then open the copy as if it had just loaded it from file. If the file image allocation callbacks are defined, the driver shall use them for all memory management tasks. Otherwise it will use the standard malloc, memcpy, realloc, and free C library calls for this purpose.</p>
<p>If the VFD sets the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag, and an initial file image is defined by an application, the VFD should ensure that file creation operations (as opposed to file open operations) bypass use of the file image, and create a new, empty file.</p>
<p>Finally, it is logically possible that a file driver would set the <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a> flag, but not the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag. While it is hard to think of a situation in which this would be desirable, setting the flags this way will not cause any problems: the two capabilities are logically distinct.</p>
<p><a class="anchor" id="FI216"></a></p><h4><a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a></h4>
<p>The purpose of the <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> routine is to provide a simple way to retrieve a copy of the image of an existing, open file. This routine can be used with files opened using the SEC2 (aka POSIX), STDIO, and Core (aka Memory) VFDs.</p>
<p>The signature of <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> is defined as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5public_8h.html#af629ed855824cf5955b54529adf78ad6">ssize_t</a> <a class="code hl_function" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a>(<a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file_id, <span class="keywordtype">void</span> *buf_ptr, <span class="keywordtype">size_t</span> buf_len)</div>
<div class="ttc" id="a_h5public_8h_html_af629ed855824cf5955b54529adf78ad6"><div class="ttname"><a href="_h5public_8h.html#af629ed855824cf5955b54529adf78ad6">ssize_t</a></div><div class="ttdeci">int ssize_t</div><div class="ttdef"><b>Definition</b> H5public.h:283</div></div>
<div class="ttc" id="agroup___h5_f_html_gadc53f4e76b1199cb5d2a8cb7fbb114ad"><div class="ttname"><a href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a></div><div class="ttdeci">ssize_t H5Fget_file_image(hid_t file_id, void *buf_ptr, size_t buf_len)</div><div class="ttdoc">Retrieves a copy of the image of an existing, open file.</div></div>
</div><!-- fragment --><p>The parameters of <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> are defined as follows: </p><ul>
<li>file_id contains the ID of the target file. </li>
<li>buf_ptr contains a pointer to the buffer into which the image of the HDF5 file is to be copied. If buf_ptr is NULL, no data will be copied, but the return value will still indicate the buffer size required (or a negative value on error). </li>
<li>buf_len contains the size of the supplied buffer. If the return value of <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> is a positive value, then the value will be the length of buffer required to store the file image (in other words, the length of the file). A negative value might be returned if the file is too large to store in the supplied buffer or on failure.</li>
</ul>
<p>The current file size can be obtained via a call to <a class="el" href="group___h5_f.html#ga515426821321c261a825b4e4a3f576fe" title="Returns the size of an HDF5 file (in bytes)">H5Fget_filesize</a>. Note that this function returns the value of the end of file (EOF) and not the end of address space (EOA). While these values are frequently the same, it is possible for the EOF to be larger than the EOA. Since <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> will only obtain a copy of the file from the beginning of the superblock to the EOA, it will be best to use <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> to determine the size of the buffer required to contain the image.</p>
<h4>Other Design Considerations</h4>
<p>Here are some other notes regarding the design and implementation of <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a>.</p>
<p>The <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> call should be part of the high-level library. However, a file driver agnostic implementation of the routine requires access to data structures that are hidden within the HDF5 Library. We chose to implement the call in the library proper rather than expose those data structures.</p>
<p>There is no reason why the <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> API call could not work on files opened with any file driver. However, the Family, Multi, and Split file drivers have issues that make the call problematic. At present, files opened with the Family file driver are marked as being created with that file driver in the superblock, and the HDF5 Library refuses to open files so marked with any other file driver. This negates the purpose of the <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> call. While this mark can be removed from the image, the necessary code is not trivial.</p>
<p>Thus we will not support the Family file driver in <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> unless there is demand for it. Files created with the Multi and Split file drivers are also marked in the superblock. In addition, they typically use a very sparse address space. A sparse address space would require the use of an impractically large buffer for an image, and most of the buffer would be empty. So, we see no point in supporting the Multi and Split file drivers in <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> under any foreseeable circumstances.</p>
<h3><a class="anchor" id="subsubsec_file_image_api_high"></a>
High-level C API Routine</h3>
<p>The <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> high-level routine encapsulates the capabilities of routines in the main HDF5 Library with conveniently accessible abstractions.</p>
<p><a class="anchor" id="FI221"></a></p><h4><a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a></h4>
<p>The <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> routine is designed to provide an easier way to open an initial file image with the Core VFD. Flags to <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> allow for various file image buffer ownership policies to be requested. See the <a class="el" href="_r_m.html">HDF5 Reference Manual</a> for more information on high-level APIs.</p>
<p>The signature of <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> is defined as follows: </p><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> <a class="code hl_function" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a>(<span class="keywordtype">void</span> *buf_ptr, <span class="keywordtype">size_t</span> buf_len, <span class="keywordtype">unsigned</span> flags)</div>
<div class="ttc" id="agroup___h5_l_t_html_ga07fcf2af194e87a3e45252544ebe4aa4"><div class="ttname"><a href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a></div><div class="ttdeci">H5_HLDLL hid_t H5LTopen_file_image(void *buf_ptr, size_t buf_size, unsigned flags)</div><div class="ttdoc">Opens an HDF5 file image in memory.</div></div>
</div><!-- fragment --><p>The parameters of <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> are defined as follows: </p><ul>
<li>buf_ptr contains a pointer to the supplied initial image. A NULL value is invalid and will cause <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> to fail. </li>
<li>buf_len contains the size of the supplied buffer. A value of 0 is invalid and will cause <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> to fail. </li>
<li>flags contains a set of flags indicating whether the image is to be opened read/write, whether HDF5 is to take control of the buffer, and how long the application promises to maintain the buffer. Possible flags are described in the table below: <a class="anchor" id="FITable3"></a>
<table class="doxtable">
<caption>Flags for <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a></caption>
<tr>
<td><a class="el" href="_h5_l_tpublic_8h.html#adb7efc091461c62bf5ab67a30c8fded6">H5LT_FILE_IMAGE_OPEN_RW</a></td><td>Indicates that the HDF5 Library should open the image read/write instead of the default read-only.  </td></tr>
<tr>
<td><a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a></td><td>Indicates that the HDF5 Library should not copy the file image buffer provided, but should use it directly. The HDF5 Library will release the file image when finished. The supplied buffer must have been allocated via a call to the standard C library malloc() or calloc() routines. The HDF5 Library will call free() to release the buffer. In the absence of this flag, the HDF5 Library will copy the buffer provided. The <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag provides an application with the ability to “give ownership” of a file image buffer to the HDF5 Library.<br  />
 The HDF5 Library will modify the buffer on write if the image is opened read/write and the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag is set.<br  />
 The <a class="el" href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a> flag, see below, is invalid unless the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag is set.  </td></tr>
<tr>
<td><a class="el" href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a></td><td>Indicates that the HDF5 Library should not attempt to release the buffer when the file is closed. This implies that the application will tend to this detail and that the application will not discard the buffer until after the file image is closed.<br  />
 Since there is no way to return a changed buffer base address to the application, and since realloc can change this value, calls to realloc() must be barred when this flag is set. As a result, any write that requires an increased buffer size will fail.<br  />
 This flag is invalid unless the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag, see above, is set.<br  />
 If the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag is set and this flag is not set, the HDF5 Library will release the file image buffer after the file is closed using the standard C library free() routine.<br  />
 Using this flag and the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> flag provides a way for the application to specify a buffer that the HDF5 Library can use for opening and accessing as a file image while letting the application retain ownership of the buffer.  </td></tr>
</table>
</li>
</ul>
<p>The following table is intended to summarize the semantics of the <a class="el" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> and <a class="el" href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a> flags (shown as “Don’t Copy Flag” and “Don’t Release Flag” respectively in the table):</p>
<a class="anchor" id="FITable4"></a>
<table class="doxtable">
<caption>Summary of Don’t Copy and Don’t Release Flag Actions</caption>
<tr>
<th>Don’t Copy Flag</th><th>Don’t Release Flag</th><th>Make Copy of User Supplied Buffer</th><th>Pass User Supplied Buffer to File Driver</th><th>Release User Supplied Buffer When Done</th><th>Permit realloc of Buffer Used by File Driver  </th></tr>
<tr>
<td>False</td><td>Don’t care</td><td>True</td><td>False</td><td>False</td><td>True  </td></tr>
<tr>
<td>True</td><td>False</td><td>False</td><td>True</td><td>True</td><td>True  </td></tr>
<tr>
<td>True</td><td>True</td><td>False</td><td>True</td><td>False</td><td>False  </td></tr>
</table>
<p>The return value of <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> will be a file ID on success or a negative value on failure. The file ID returned should be closed with <a class="el" href="group___h5_f.html#gac55cd91d80822e4f8c2a7f04ea71b124" title="Terminates access to an HDF5 file.">H5Fclose</a>.</p>
<p>Note that there is no way currently to specify a “backing store” file name in this definition of <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a>.</p>
<h2><a class="anchor" id="subsec_file_image_semantics"></a>
C API Call Semantics</h2>
<p>The purpose of this chapter is to describe some issues that developers should consider when using file image buffers, property lists, and callback APIs.</p>
<h3><a class="anchor" id="subsubsec_file_image_semantics_cbk"></a>
File Image Callback Semantics</h3>
<p>The <a class="el" href="group___f_a_p_l.html#gae17e38082dfdbadd75c897f1e6a9096e" title="Retrieves callback routines for working with file images.">H5Pget_file_image_callbacks</a>/<a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> API calls allow an application to hook the memory management operations used when allocating, duplicating, and discarding file images in the property list, in the Core file driver, and potentially in any in-memory file driver developed in the future.</p>
<p>From the perspective of the HDF5 Library, the supplied image_malloc(), image_memcpy(), image_realloc(), and image_free() callback routines must function identically to the C standard library malloc(), memcpy(), realloc(), and free() calls. What happens on the application side can be much more nuanced, particularly with the ability to pass user data to the callbacks. However, whatever the application does with these calls, it must maintain the illusion that the calls have had the expected effect. Maintaining this illusion requires some understanding of how the property list structure works, and what HDF5 will do with the initial images passed to it.</p>
<p>At the beginning of this document, we talked about the need to work within the constraints of the property list mechanism. When we said “from the perspective of the HDF5 Library…” in the paragraph above, we are making reference to this point.</p>
<p>The property list mechanism was developed as a way to add parameters to functions without changing the parameter list and breaking existing code. However, it was designed to use only “call by value” semantics, not “call by reference”. The decision to use “call by value” semantics requires that the values of supplied variables be copied into the property list. This has the advantage of simplifying the copying and deletion of property lists. However, if the value to be copied is large (say a 2 GB file image), the overhead can be unacceptable.</p>
<p>The usual solution to this problem is to use “call by reference” where only a pointer to an object is placed in a parameter list rather than a copy of the object itself. However, use of “call by reference” semantics would greatly complicate the property list mechanism: at a minimum, it would be necessary to maintain reference counts to dynamically allocated objects so that the owner of the object would know when it was safe to free the object.</p>
<p>After much discussion, we decided that the file image operations calls were sufficiently specialized that it made no sense to rework the property list mechanism to support “call by reference.” Instead we provided the file image callback mechanism to allow the user to implement some version of “call by reference” when needed. It should be noted that we expect this mechanism to be used rarely if at all. For small file images, the copying overhead should be negligible, and for large images, most use cases should be addressed by the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> call.</p>
<p>In the (hopefully) rare event that use of the file image callbacks is necessary, the fundamental point to remember is that the callbacks must be constructed and used in such a way as to maintain the library’s illusion that it is using “call by value” semantics.</p>
<p>Thus the property list mechanism must think that it is allocating a new buffer and copying the supplied buffer into it when the file image property is set. Similarly, it must think that it is allocating a new buffer and copying the contents of the existing buffer into it when it copies a property list that contains a file image. Likewise, it must think it is de-allocating a buffer when it discards a property list that contains a file image.</p>
<p>Similar illusions must be maintained when a file image buffer is copied into the Core file driver (or any future driver that uses the file image callbacks) when the file driver re-sizes the buffer containing the image and finally when the driver discards the buffer.</p>
<p><a class="anchor" id="FI311"></a></p><h4>Buffer Ownership</h4>
<p>The owner of a file image in a buffer is the party that has the responsibility to discard the file image buffer when it is no longer needed. In this context, the owner is either the HDF5 Library or the application program.</p>
<p>We implemented the image_* callback facility to allow efficient management of large file images. These facilities can be used to allow sharing of file image buffers between the application and the HDF5 library, and also transfer of ownership in either direction. In such operations, care must be taken to ensure that ownership is clear and that file image buffers are not discarded before all references to them are discarded by the non-owning party.</p>
<p>Ownership of a file image buffer will only be passed to the application program if the file image callbacks are designed to do this. In such cases, the application program must refrain from freeing the buffer until the library has deleted all references to it. This in turn will happen after all property lists (if any) that refer to the buffer have been discarded, and the file driver (if any) that used the buffer has closed the file and thinks it has discarded the buffer.</p>
<p><a class="anchor" id="FI312"></a></p><h4>Sharing a File image Buffer with the HDF5 Library</h4>
<p>As mentioned above, the HDF5 property lists are a mechanism for passing values into HDF5 Library calls. They were created to allow calls to be extended with new parameters without changing the actual API or breaking existing code. They were designed based on the assumption that all new parameters would be “call by value” and not “call by reference.” Having “call by value” parameters means property lists can be copied, reused, and discarded with ease.</p>
<p>Suppose an application wished to share a file image buffer with the HDF5 Library. This means the library would be allowed to read the file image, but not free it. The file image callbacks might be constructed as follows to share a buffer: </p><ul>
<li>Construct the image_malloc() call so that it returns the address of the buffer instead of allocating new space. This will keep the library thinking that the buffers are distinct even when they are not. Support this by including the address of the buffer in the user data. As a sanity check, include the buffer’s size in the user data as well, and require image_malloc() to fail if the requested buffer size is unexpected. Finally, include a reference counter in the user data, and increment the reference counter on each call to image_malloc(). </li>
<li>Construct the image_memcpy() call so that it does nothing. As a sanity check, make it fail if the source and destination pointers do not match the buffer address in the user data or if the size is unexpected. </li>
<li>Construct the image_free() routine so that it does nothing. As a sanity check, make it compare the supplied pointer with the expected pointer in the user data. Also, make it decrement the reference counter and notify the application that the HDF5 Library is done with the buffer when the reference count drops to 0.</li>
</ul>
<p>As the property list code will never resize a buffer, we do not discuss the image_realloc() call here. The behavior of image_realloc() in this scenario depends on what the application wants to do with the file image after it has been opened. We discuss this issue in the next section. Note also that the operation passed into the file image callbacks allow the callbacks to behave differently depending on the context in which they are used.</p>
<p>For more information on user defined data, see the <a class="el" href="_h5_f_i_m__u_g.html#subsubsec_file_image_semantics_cbk">File Image Callback Semantics</a> section.</p>
<p><a class="anchor" id="FI313"></a></p><h4>File Driver Considerations</h4>
<p>When a file image is opened by a driver that sets both the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> and the <a class="el" href="_h5_f_dpublic_8h.html#ab737a473dca3020847b2f713ad17f3c7">H5FD_FEAT_CAN_USE_FILE_IMAGE_CALLBACKS</a> flags, the driver will allocate a buffer large enough for the initial file image and then copy the image from the property list into this buffer. As processing progresses, the driver will reallocate the image as necessary to increase its size and will eventually discard the image at file close. If defined, the driver will use the file image callbacks for these operations; otherwise, the driver will use the standard C library calls. See the <a class="el" href="_h5_f_i_m__u_g.html#subsubsec_file_image_semantics_cbk">File Image Callback Semantics</a> section for more information.</p>
<p>As described above, the file image callbacks can be constructed so as to avoid the overhead of buffer allocations and copies while allowing the HDF5 Library to maintain its illusions on the subject. There are two possible complications involving the file driver. The complications are the possibility of reallocation calls from the driver and the possibility of the continued existence of property lists containing references to the buffer.</p>
<p>Suppose an application wishes to share a file image buffer with the HDF5 Library. The application allows the library to read (and possibly write) the image, but not free it. We must first decide whether the image is to be opened read-only or read/write.</p>
<p>If the image will be opened read-only (or if we know that any writes will not change the size of the image), the image_realloc() call should never be invoked. Thus the image_realloc() routine can be constructed so as to always fail, and the image_malloc(), image_memcpy(), and image_free() routines can be constructed as described in the section above.</p>
<p>Suppose, however, that the file image will be opened read/write and may grow during the computation. We must now allow for the base address of the buffer to change due to reallocation calls, and we must employ the user data structure to communicate any change in the buffer base address and size to the application. We pass buffer changes to the application so that the application will be able to eventually free the buffer. To this end, we might define a user data structure as shown in the example below:</p>
<p><em>Using a user data structure to communicate with an application</em> </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>udata {</div>
<div class="line">    <span class="keywordtype">void</span>  *init_ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> init_size;</div>
<div class="line">    <span class="keywordtype">int</span>    init_ref_count;</div>
<div class="line">    <span class="keywordtype">void</span>  *mod_ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> mod_size;</div>
<div class="line">    <span class="keywordtype">int</span>    mod_ref_count;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We initialize an instance of the structure so that init_ptr points to the buffer to be shared, init_size contains the initial size of the buffer, and all other fields are initialized to either NULL or 0 as indicated by their type. We then pass a pointer to the instance of the user data structure to the HDF5 Library along with allocation callback functions constructed as follows: </p><ul>
<li>Construct the image_malloc() call so that it returns the value in the init_ptr field of the user data structure and increments the init_ref_count. As a sanity check, the function should fail if the requested size does not match the init_size field in the user data structure or if any of the modified fields have values other than their initial values. </li>
<li>Construct the image_memcpy() call so that it does nothing. As a sanity check, it should be made to fail if the source, destination, and size parameters do not match the init_ptr and init_size fields as appropriate. </li>
<li>Construct the image_realloc() call so that it performs a standard realloc. Sanity checking, assuming that the realloc is successful, should be as follows: <ul>
<li>
If the mod_ptr, mod_size, or mod_ref_count fields of the user data structure still have their initial values, verify that the supplied pointer matches the init_ptr field and that the supplied size does not match the init_size field. Decrement init_ref_count, set mod_ptr equal to the address returned by realloc, set mod_size equal to the supplied size, and set mod_ref_count to 1. </li>
<li>
If the mod_ptr, mod_size, or mod_ref_count fields of the user data structure are defined, verify that the supplied pointer matches the value of mod_ptr and that the supplied size does not match mod_size. Set mod_ptr equal to the value returned by realloc, and set mod_size equal to the supplied size. </li>
</ul>
In both cases, if all sanity checks pass, return the value returned by the realloc call. Otherwise, return NULL. </li>
<li>Construct the image_free() routine so that it does nothing. Perform sanity checks as follows: <ul>
<li>
If the <a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a> flag is set, decrement the init_ref_count field of the user data structure. Flag an error if init_ref_count drops below zero. </li>
<li>
If the <a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a> flag is set, check to see if the mod_ptr, mod_size, or mod_ref_count fields of the user data structure have been modified from their initial values. If they have, verify that mod_ref_count contains 1 and then set that field to zero. If they have not been modified, proceed as per the <a class="el" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a> case. </li>
</ul>
</li>
</ul>
<p>In either case, if both the init_ref_count and mod_ref_count fields have dropped to zero, notify the application that the HDF5 Library is done with the buffer. If the mod_ptr or mod_size fields have been modified, pass these values on to the application as well.</p>
<h3><a class="anchor" id="subsubsec_file_image_semantics_init"></a>
Initial File Image Semantics</h3>
<p>One can argue whether creating a file with an initial file image is closer to creating a file or opening a file. The consensus seems to be that it is closer to a file open, and thus we shall require that the initial image only be used for calls to <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a>.</p>
<p>Whatever our convention, from an internal perspective, opening a file with an initial file image is a bit of both creating a file and opening a file. Conceptually, we will create a file on disk, write the supplied image to the file, close the file, open the file as an HDF5 file, and then proceed as usual (of course, the Core VFD will not write to the file system unless it is configured to do so). This process is similar to a file create: we are creating a file that did not exist on disk to begin with and writing data to it. Also, we must verify that no file of the supplied name is open. However, this process is also similar to a file open: we must read the superblock and handle the usual file open tasks.</p>
<p>Implementing the above sequence of actions has a number of implications on the behavior of the <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call when an initial file image is supplied: </p><ul>
<li><a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> must fail if the target file driver does not set the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag and a file image is specified in the FAPL. </li>
<li>If the target file driver supports the <a class="el" href="_h5_f_dpublic_8h.html#af55fc4553f24c5dac13ec3f2499b04f0">H5FD_FEAT_ALLOW_FILE_IMAGE</a> flag, then <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> must fail if the file is already open or if a file of the specified name exists. </li>
<li>Even if the above constraints are satisfied, <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> must still fail if the image does not contain a valid (or perhaps just plausibly valid) image of an HDF5 file. In particular, the superblock must be processed, and the file structure be set up accordingly.</li>
</ul>
<p>See the <a class="el" href="_h5_f_i_m__u_g.html#FI215">FI215</a> section for more information.</p>
<p>As we indicated earlier, if an initial file image appears in the property list of an <a class="el" href="group___h5_f.html#gae64b51ee9ac0781bc4ccc599d98387f4" title="Creates an HDF5 file.">H5Fcreate</a> call, it is ignored.</p>
<p>While the above section on the semantics of the file image callbacks may seem rather gloomy, we get the payback here. The above says everything that needs to be said about initial file image semantics in general. The sub-section below has a few more observations on the Core file driver.</p>
<p><a class="anchor" id="FI321"></a></p><h4>Applying Initial File Image Semantics to the Core File Driver</h4>
<p>At present, the Core file driver uses the open() and read() system calls to load an HDF5 file image from the file system into RAM. Further, if the backing_store flag is set in the FAPL entry specifying the use of the Core file driver, the Core file driver’s internal image will be used to overwrite the source file on either flush or close. See the <a class="el" href="group___f_a_p_l.html#ga6e6628f620a1c58c704129cf07282849" title="Modifies the file access property list to use the H5FD_CORE driver.">H5Pset_fapl_core</a> entry in the <a class="el" href="_r_m.html">HDF5 Reference Manual</a> for more information.</p>
<p>This results in the following observations. In all cases assume that use of the Core file driver has been specified in the FAPL. </p><ul>
<li>If the file specified in the <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call does not exist, and no initial image is specified in the FAPL, the open must fail because there is no source for the initial image needed by the Core file driver. </li>
<li>If the file specified in the <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call does exist, and an initial image is specified in the FAPL, the open must fail because the source of the needed initial image is ambiguous: the file image could be taken either from file or from the FAPL. </li>
<li>If the file specified in the <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call does not exist, and an initial image is specified in the FAPL, the open will succeed. This assumes that the supplied image is valid. Further, if the backing store flag is set, the file specified in the <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> call will be created, and the contents of the Core file driver’s internal buffer will be written to the new file on flush or close.</li>
</ul>
<p>Thus a call to <a class="el" href="group___h5_f.html#gaa3f4f877b9bb591f3880423ed2bf44bc" title="Opens an existing HDF5 file.">H5Fopen</a> can result in the creation of a new HDF5 file in the file system.</p>
<h2><a class="anchor" id="subsec_file_image_example"></a>
Examples</h2>
<p>The purpose of this chapter is to provide examples of how to read or build an in-memory HDF5 file image.</p>
<h3><a class="anchor" id="subsubsec_file_image_example_read"></a>
Reading an In-memory HDF5 File Image</h3>
<p>The <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> function call allows the Core file driver to be initialized from an application provided buffer. The following pseudo code illustrates its use:</p>
<p><em>Example 2. Using <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> to initialize the Core file driver</em> </p><div class="fragment"><div class="line">&lt;allocate and initialize buf_len and buf&gt;</div>
<div class="line">&lt;allocate fapl_id&gt;</div>
<div class="line">&lt;set fapl to use Core file driver&gt;</div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a>(fapl_id, buf, buf_len);</div>
<div class="line">&lt;discard buf any time after <span class="keyword">this</span> point&gt;</div>
<div class="line">&lt;open file&gt;</div>
<div class="line">&lt;discard fapl any time after <span class="keyword">this</span> point&gt;</div>
<div class="line">&lt;read and/or write file as desired, close&gt;</div>
</div><!-- fragment --><p>This solution is easy to code, but the supplied buffer is duplicated twice. The first time is in the call to <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> when the image is duplicated and the duplicate inserted into the property list. The second time is when the file is opened: the image is copied from the property list into the initial buffer allocated by the Core file driver. This is a non-issue for small images, but this could become a significant performance hit for large images.</p>
<p>If we want to avoid the extra malloc and memcpy calls, we must decide whether the application should retain ownership of the buffer or pass ownership to the HDF5 Library.</p>
<p>The following pseudo code illustrates opening the image read-only using the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image()</a> routine. In this example, the application retains ownership of the buffer and avoids extra buffer allocations and memcpy calls.</p>
<p><em>Example 3. Using H5LTopen_file_image to open a read-only file image where the application retains ownership of the buffer</em> </p><div class="fragment"><div class="line"> &lt;allocate and initialize buf_len and buf&gt; <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file_id; <span class="keywordtype">unsigned</span> flags</div>
<div class="line">= <a class="code hl_define" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> | <a class="code hl_define" href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a>; file_id = <a class="code hl_function" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a>(buf, buf_len,</div>
<div class="line">flags); &lt;read file as desired, and then close&gt; &lt;discard buf any time after <span class="keyword">this</span> point&gt; </div>
<div class="ttc" id="a_h5_l_tpublic_8h_html_a6765cc939c4a8e1d9630f09bf177a761"><div class="ttname"><a href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a></div><div class="ttdeci">#define H5LT_FILE_IMAGE_DONT_RELEASE</div><div class="ttdef"><b>Definition</b> H5LTpublic.h:20</div></div>
<div class="ttc" id="a_h5_l_tpublic_8h_html_a9f2c5bfc75d6c23f20c3a303934c20a8"><div class="ttname"><a href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a></div><div class="ttdeci">#define H5LT_FILE_IMAGE_DONT_COPY</div><div class="ttdef"><b>Definition</b> H5LTpublic.h:18</div></div>
</div><!-- fragment --><p>If the application wants to transfer ownership of the buffer to the HDF5 Library, and the standard C library routine free is an acceptable way of discarding it, the above example can be modified as follows:</p>
<p><em>Example 4. Using H5LTopen_file_image to open a read-only file image where the application transfers ownership of the buffer</em> </p><div class="fragment"><div class="line"> &lt;allocate and initialize buf_len and buf&gt; <a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file_id; <span class="keywordtype">unsigned</span> flags</div>
<div class="line">= <a class="code hl_define" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a>; file_id = <a class="code hl_function" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a>(buf, buf_len, flags); &lt;read file as desired, and</div>
<div class="line">then close&gt; </div>
</div><!-- fragment --><p>Again, file access is read-only. Read/write access can be obtained via the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> call, but we will explore that in the section below.</p>
<h3><a class="anchor" id="subsubsec_file_image_example_const"></a>
In-memory HDF5 File Image Construction</h3>
<p>Before the implementation of file image operations, HDF5 supported construction of an image of an HDF5 file in memory with the Core file driver. The <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> function call allows an application access to the file image without first writing it to disk. See the following code fragment:</p>
<p><em>Example 5. Accessing the image of a file in memory</em> </p><div class="fragment"><div class="line">&lt;Open and construct the desired file with the Core file driver&gt;</div>
<div class="line"><a class="code hl_function" href="group___h5_f.html#gae686870f0a276c4d06bbc667b2c24124">H5Fflush</a>(fid);</div>
<div class="line">size = <a class="code hl_function" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a>(fid, NULL, 0);</div>
<div class="line">buffer_ptr = malloc(size);</div>
<div class="line"><a class="code hl_function" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a>(fid, buffer_ptr, size);</div>
<div class="ttc" id="agroup___h5_f_html_gae686870f0a276c4d06bbc667b2c24124"><div class="ttname"><a href="group___h5_f.html#gae686870f0a276c4d06bbc667b2c24124">H5Fflush</a></div><div class="ttdeci">herr_t H5Fflush(hid_t object_id, H5F_scope_t scope)</div><div class="ttdoc">Flushes all buffers associated with a file to storage.</div></div>
</div><!-- fragment --><p>The use of <a class="el" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad" title="Retrieves a copy of the image of an existing, open file.">H5Fget_file_image</a> may be acceptable for small images. For large images, the cost of the malloc() and memcpy() operations may be excessive. To address this issue, the <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> call allows an application to manage dynamic memory allocation for file images and memory-based file drivers (only the Core file driver at present). The following code fragment illustrates its use. Note that most error checking is omitted for simplicity and that <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a> is not used to set the initial file image.</p>
<p><em>Example 6. Using <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> to improve memory allocation</em> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>udata_t {</div>
<div class="line">    <span class="keywordtype">void</span> * image_ptr;</div>
<div class="line">    <span class="keywordtype">size_t</span> image_size;</div>
<div class="line">} udata = {NULL, 0};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *image_malloc(<span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_size = size;</div>
<div class="line">    <span class="keywordflow">return</span>(malloc(size));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *image_memcpy)(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> size,</div>
<div class="line">        <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    assert(FALSE); <span class="comment">// Should never be invoked in this scenario.</span></div>
<div class="line">    <span class="keywordflow">return</span>(NULL); <span class="comment">// always fails</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> image_realloc(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_size = size;</div>
<div class="line">    <span class="keywordflow">return</span>(realloc(ptr, size));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> image_free(<span class="keywordtype">void</span> *ptr, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    assert(file_image_op == <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a>);</div>
<div class="line">    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_ptr = ptr;</div>
<div class="line">    <span class="keywordflow">return</span>(0); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *udata_copy(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">    <span class="keywordflow">return</span>(udata);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> udata_free(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">    <span class="keywordflow">return</span>(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> callbacks = {image_malloc, image_memcpy,</div>
<div class="line">         image_realloc, image_free, udata_copy, udata_free, (<span class="keywordtype">void</span> *)(&amp;udata)};</div>
<div class="line"> </div>
<div class="line">&lt;allocate fapl_id&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a>(fapl_id, &amp;callbacks);</div>
<div class="line"> </div>
<div class="line">&lt;open core file <span class="keyword">using </span>fapl_id, write file, close it&gt;</div>
<div class="line"> </div>
<div class="line">assert(udata.image_ptr!= NULL);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// udata now contains the base address and length of the final version of the core file</span></div>
<div class="line"> </div>
<div class="line">&lt;use image of file, and then discard it via free()&gt;</div>
</div><!-- fragment --><p>The above code fragment gives the application full ownership of the buffer used by the Core file driver after the file is closed, and it notifies the application that the HDF5 Library is done with the buffer by setting udata.image_ptr to something other than NULL. If read access to the buffer is sufficient, the <a class="el" href="group___h5_f.html#gae4020a66fb8da0586e3b74c81ffccea4" title="Returns pointer to the file handle from the virtual file driver.">H5Fget_vfd_handle</a> call can be used as an alternate solution to get access to the base address of the Core file driver’s buffer.</p>
<p>The above solution avoids some unnecessary malloc and memcpy calls and should be quite adequate if an image of an HDF5 file is constructed only occasionally. However, if an HDF5 file image must be constructed regularly, and if we can put a strong and tight upper bound on the size of the necessary buffer, then the following pseudo code demonstrates a method of avoiding memory allocation completely. The downside, however, is that buffer is allocated statically. Again, much error checking is omitted for clarity.</p>
<p><em>Example 7. Using <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> with a static buffer</em> </p><div class="fragment"><div class="line">    <span class="keywordtype">char</span> buf[BIG_ENOUGH];</div>
<div class="line">    <span class="keyword">struct </span>udata_t {</div>
<div class="line">        <span class="keywordtype">void</span> * image_ptr;</div>
<div class="line">        <span class="keywordtype">size_t</span> image_size;</div>
<div class="line">        <span class="keywordtype">size_t</span> max_image_size;</div>
<div class="line">        <span class="keywordtype">int</span> ref_count;</div>
<div class="line">    } udata = {(<span class="keywordtype">void</span> *)(&amp;(buf[0]), 0, BIG_ENOUGH, 0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *image_malloc(<span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        assert(size &lt;= ((<span class="keyword">struct</span> udata_t *)udata)-&gt;max_image_size);</div>
<div class="line">        assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count == 0);</div>
<div class="line">        ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_size = size;</div>
<div class="line">        (((<span class="keyword">struct </span>udata_t *)udata)-&gt;ref_count)++;</div>
<div class="line">        <span class="keywordflow">return</span>((((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *image_memcpy)(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span></div>
<div class="line">*udata) { assert(FALSE); <span class="comment">// Should never be invoked in this scenario. return(NULL); // always fails</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *image_realloc(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">        assert(size &lt;= ((<span class="keyword">struct</span> udata_t *)udata)-&gt;max_image_size);</div>
<div class="line">        assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count == 1);</div>
<div class="line">        ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_size = size;</div>
<div class="line">        <span class="keywordflow">return</span>((((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> image_free(<span class="keywordtype">void</span> *ptr, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        assert(file_image_op == <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a>);</div>
<div class="line">        assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">        assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count == 1);</div>
<div class="line">        (((<span class="keyword">struct </span>udata_t *)udata)-&gt;ref_count)--;</div>
<div class="line">        <span class="keywordflow">return</span>(0); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *udata_copy(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordflow">return</span>(udata);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> udata_free(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordflow">return</span>(0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> callbacks = {image_malloc, image_memcpy, image_realloc, image_free,</div>
<div class="line">                                           udata_copy, udata_free, (<span class="keywordtype">void</span> *)(&amp;udata)};</div>
<div class="line">    <span class="comment">// end of initialization</span></div>
<div class="line"> </div>
<div class="line">    &lt;allocate fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a>(fapl_id, &amp;callbacks);</div>
<div class="line"> </div>
<div class="line">    &lt;open core file <span class="keyword">using </span>fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;discard fapl any time after the open&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;write the file, flush it, and then close it&gt;</div>
<div class="line"> </div>
<div class="line">    assert(udata.ref_count == 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// udata now contains the base address and length of the final version of the core file</span></div>
<div class="line">    &lt;use the image of the file&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;reinitialize udata, and repeat the above from the end of initialization onwards to write a <span class="keyword">new</span> file</div>
<div class="line">image&gt; </div>
</div><!-- fragment --><p>If we can further arrange matters so that only the contents of the datasets in the HDF5 file image change, but not the structure of the file itself, we can optimize still further by reusing the image and changing only the contents of the datasets after the initial write to the buffer. The following pseudo code shows how this might be done. Note that the code assumes that buf already contains the image of the HDF5 file whose dataset contents are to be overwritten. Again, much error checking is omitted for clarity. Also, observe that the file image callbacks do not support the <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image</a> call.</p>
<p><em>Example 8. Using <a class="el" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c" title="Sets the callbacks for working with file images.">H5Pset_file_image_callbacks</a> where only the datasets change</em> </p><div class="fragment"><div class="line">&lt;buf already defined and loaded with file image&gt;</div>
<div class="line"> </div>
<div class="line">&lt;udata already defined and initialized&gt;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *image_malloc(<span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    assert(size &lt;= ((<span class="keyword">struct</span> udata_t *)udata)-&gt;max_image_size);</div>
<div class="line">    assert(size == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_size);</div>
<div class="line">    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count &gt;= 0);</div>
<div class="line">    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;image_size = size;</div>
<div class="line">    (((<span class="keyword">struct </span>udata_t *)udata)-&gt;ref_count)++;</div>
<div class="line">    <span class="keywordflow">return</span>((((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *image_memcpy)(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> size,</div>
<div class="line">    <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    assert(dest == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">    assert(src == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">    assert(size &lt;= ((<span class="keyword">struct</span> udata_t *)udata)-&gt;max_image_size);</div>
<div class="line">    assert(size == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_size);</div>
<div class="line">    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count &gt;= 1);</div>
<div class="line">    <span class="keywordflow">return</span>(dest); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *image_realloc(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    <span class="comment">// One would think that this function is not needed in this scenario, as</span></div>
<div class="line">    <span class="comment">// only the contents of the HDF5 file is being changed, not its size or</span></div>
<div class="line">    <span class="comment">// structure. However, the Core file driver calls realloc() just before</span></div>
<div class="line">    <span class="comment">// close to clip the buffer to the size indicated by the end of the</span></div>
<div class="line">    <span class="comment">// address space.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    <span class="comment">// While this call must be supported in this case, the size of</span></div>
<div class="line">    <span class="comment">// the image should never change. Hence the function can limit itself</span></div>
<div class="line">    <span class="comment">// to performing sanity checks, and returning the base address of the</span></div>
<div class="line">    <span class="comment">// statically allocated buffer.</span></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line">    assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">    assert(size &lt;= ((<span class="keyword">struct</span> udata_t *)udata)-&gt;max_image_size);</div>
<div class="line">    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count &gt;= 1);</div>
<div class="line">    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_size == size);</div>
<div class="line">    <span class="keywordflow">return</span>((((<span class="keyword">struct</span> udata_t *)udata)-&gt;image_ptr);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> image_free(<span class="keywordtype">void</span> *ptr, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">    assert((file_image_op == <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a>) ||</div>
<div class="line">           (file_image_op == <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a>));</div>
<div class="line">    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;ref_count &gt;= 1);</div>
<div class="line">    (((<span class="keyword">struct </span>udata_t *)udata)-&gt;ref_count)--;</div>
<div class="line">    <span class="keywordflow">return</span>(0); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> *udata_copy(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">    <span class="keywordflow">return</span>(udata);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> udata_free(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">    <span class="keywordflow">return</span>(0);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> callbacks = {image_malloc, image_memcpy, image_realloc, image_free,</div>
<div class="line">                                       udata_copy, udata_free, (<span class="keywordtype">void</span> *)(&amp;udata)};</div>
<div class="line"><span class="comment">// end of initialization</span></div>
<div class="line"> </div>
<div class="line">&lt;allocate fapl_id&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a>(fapl_id, &amp;callbacks);</div>
<div class="line"><a class="code hl_function" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a>(fapl_id, udata.image_ptr, udata.image_len);</div>
<div class="line"> </div>
<div class="line">&lt;open core file <span class="keyword">using </span>fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">&lt;discard fapl any time after the open&gt;</div>
<div class="line"> </div>
<div class="line">&lt;overwrite data in datasets in the file, and then close it&gt;</div>
<div class="line"> </div>
<div class="line">assert(udata.ref_count == 0);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// udata now contains the base address and length of the final version of the core file</span></div>
<div class="line">&lt;use the image of the file&gt;</div>
<div class="line"> </div>
<div class="line">&lt;repeat the above from the end of initialization onwards to write <span class="keyword">new</span> data to datasets in file image&gt;</div>
</div><!-- fragment --><p>Before we go on, we should note that the above pseudo code can be written more compactly, albeit with fewer sanity checks, using the <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> call. See the example below:</p>
<p><em>Example 9. Using <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> where only the datasets change</em> </p><div class="fragment"><div class="line">&lt;buf already defined and loaded with file image&gt;</div>
<div class="line"> </div>
<div class="line">&lt;udata already defined and initialized&gt;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file_id;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">unsigned</span> flags = <a class="code hl_define" href="_h5_l_tpublic_8h.html#adb7efc091461c62bf5ab67a30c8fded6">H5LT_FILE_IMAGE_OPEN_RW</a> | <a class="code hl_define" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a> | <a class="code hl_define" href="_h5_l_tpublic_8h.html#a6765cc939c4a8e1d9630f09bf177a761">H5LT_FILE_IMAGE_DONT_RELEASE</a>;</div>
<div class="line"><span class="comment">// end initialization</span></div>
<div class="line"> </div>
<div class="line">file_id = <a class="code hl_function" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a>(udata.image_ptr, udata.image_len, flags);</div>
<div class="line"> </div>
<div class="line">&lt;overwrite data in datasets in the file, and then close it&gt;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// udata now contains the base address and length of the final version of the core file</span></div>
<div class="line">&lt;use the image of the file&gt;</div>
<div class="line"> </div>
<div class="line">&lt;repeat the above from the end of initialization onwards to write <span class="keyword">new</span> data to datasets in file image&gt;</div>
<div class="ttc" id="a_h5_l_tpublic_8h_html_adb7efc091461c62bf5ab67a30c8fded6"><div class="ttname"><a href="_h5_l_tpublic_8h.html#adb7efc091461c62bf5ab67a30c8fded6">H5LT_FILE_IMAGE_OPEN_RW</a></div><div class="ttdeci">#define H5LT_FILE_IMAGE_OPEN_RW</div><div class="ttdef"><b>Definition</b> H5LTpublic.h:17</div></div>
</div><!-- fragment --><p>While the scenario above is plausible, we will finish this section with a more general scenario. In the pseudo code below, we assume sufficient RAM to retain the HDF5 file image between uses, but we do not assume that the HDF5 file structure remains constant or that we can place a hard per bound on the image size.</p>
<p>Since we must use malloc, realloc, and free in this example, and since realloc can change the base address of a buffer, we must maintain two of ptr, size, and ref_count triples in the udata structure. The first triple is for the property list (which will never change the buffer), and the second triple is for the file driver. As shall be seen, this complicates the file image callbacks considerably. Note also that while we do not use <a class="el" href="group___f_a_p_l.html#ga337626cc516d5d1e3303ea6bc350e56b" title="Retrieves a copy of the file image designated as the initial content and structure of a file.">H5Pget_file_image()</a> in this example, we do include support for it in the file image callbacks. As usual, much error checking is omitted in favor of clarity.</p>
<p><em>Example 10. Using <a class="el" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4" title="Opens an HDF5 file image in memory.">H5LTopen_file_image</a> where only the datasets change and where the file structure and image size might not be constant</em> </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>udata_t { <span class="keywordtype">void</span>* fapl_image_ptr; <span class="keywordtype">size_t</span> fapl_image_size;</div>
<div class="line">        <span class="keywordtype">int</span> fapl_ref_count;</div>
<div class="line">        <span class="keywordtype">void</span>* vfd_image_ptr;</div>
<div class="line">        <span class="keywordtype">size_t</span> vfd_image_size;</div>
<div class="line">        <span class="keywordtype">int</span> vfd_ref_count;</div>
<div class="line">    } udata = {NULL, 0, 0, NULL, 0, 0};</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">boolean</span> initial_file_open = TRUE;</div>
<div class="line">    <span class="keywordtype">void</span> *image_malloc(<span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordtype">void</span> * return_value = NULL;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">switch</span> ( file_image_op ) {</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</a>:</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</a>:</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr != NULL);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_size == size);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 0);</div>
<div class="line">                return_value = ((<span class="keyword">struct </span>udata_t *)udata)-&gt;fapl_image_ptr;</div>
<div class="line">                (((<span class="keyword">struct </span>udata_t *)udata)-&gt;fapl_ref_count)++;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</a>:</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr != NULL);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_size == size);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 1);</div>
<div class="line">                return_value = ((<span class="keyword">struct </span>udata_t *)udata)-&gt;fapl_image_ptr;</div>
<div class="line">                <span class="comment">// don’t increment ref count</span></div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc">H5FD_FILE_IMAGE_OP_FILE_OPEN</a>:</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_ptr == NULL);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_size == 0);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_ref_count == 0);</div>
<div class="line">                <span class="keywordflow">if</span> (((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr == NULL ) {</div>
<div class="line">                    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_ptr = malloc(size);</div>
<div class="line">                    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_size = size;</div>
<div class="line">                }</div>
<div class="line">                <span class="keywordflow">else</span> {</div>
<div class="line">                    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_size == size);</div>
<div class="line">                    assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 1);</div>
<div class="line">                    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_ptr = ((<span class="keyword">struct </span>udata_t *)udata)-&gt;fapl_image_ptr;</div>
<div class="line">                    ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_size = size;</div>
<div class="line">                }</div>
<div class="line">                return_value = ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_ptr;</div>
<div class="line">                (((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_ref_count)++;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                assert(FALSE);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span>(return_value);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *image_memcpy)(<span class="keywordtype">void</span> *dest, <span class="keyword">const</span> <span class="keywordtype">void</span> *src, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span></div>
<div class="line">*udata) { <span class="keywordflow">switch</span>(file_image_op) { <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddad3f1a08d78d24f99705bc5fc8a249123">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_SET</a>: <span class="keywordflow">case</span></div>
<div class="line"><a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008ddacb33fad1a4edf0f8e84d79fe026dcccc">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_COPY</a>: <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda96e2ba60483056e7723abc467ce247c7">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_GET</a>: assert(dest == ((<span class="keyword">struct</span></div>
<div class="line">udata_t *)udata)-&gt;fapl_image_ptr); assert(src == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr); assert(size ==</div>
<div class="line">((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_size); assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 1); <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda4938a7bef146b2185c711e7fbb8df2cc">H5FD_FILE_IMAGE_OP_FILE_OPEN</a>:</div>
<div class="line">                assert(dest == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_ptr);</div>
<div class="line">                assert(src == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr);</div>
<div class="line">                assert(size == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_size);</div>
<div class="line">                assert(size == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_size);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 1);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_ref_count == 1);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                assert(FALSE);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span>(dest); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *image_realloc(<span class="keywordtype">void</span> *ptr, <span class="keywordtype">size_t</span> size, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_ptr);</div>
<div class="line">        assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_ref_count == 1);</div>
<div class="line">        ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_ptr = realloc(ptr, size);</div>
<div class="line">        ((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_image_size = size;</div>
<div class="line">        <span class="keywordflow">return</span>((((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_ptr);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> image_free(<span class="keywordtype">void</span> *ptr, <a class="code hl_enumeration" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dd">H5FD_file_image_op_t</a> file_image_op, <span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordflow">switch</span>(file_image_op) {</div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda17c03c08f4185a5a2c40be82d9795356">H5FD_FILE_IMAGE_OP_PROPERTY_LIST_CLOSE</a>:</div>
<div class="line">                assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_image_ptr);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;fapl_ref_count &gt;= 1);</div>
<div class="line">                (((<span class="keyword">struct </span>udata_t *)udata)-&gt;fapl_ref_count)--;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="_h5_f_dpublic_8h.html#aa95ee1806ea4db9f035cd53844c008dda9dd8cfa5ee60537d396c98e8d0646f65">H5FD_FILE_IMAGE_OP_FILE_CLOSE</a>:</div>
<div class="line">                assert(ptr == ((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_image_ptr);</div>
<div class="line">                assert(((<span class="keyword">struct</span> udata_t *)udata)-&gt;vfd_ref_count == 1);</div>
<div class="line">                (((<span class="keyword">struct </span>udata_t *)udata)-&gt;vfd_ref_count)--;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">default</span>:</div>
<div class="line">                assert(FALSE);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span>(0); <span class="comment">// if we get here, we must have been successful</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> *udata_copy(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordflow">return</span>(udata);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_typedef" href="_h5public_8h.html#a3b079ecf932a5c599499cf7e298af160">herr_t</a> udata_free(<span class="keywordtype">void</span> *udata) {</div>
<div class="line">        <span class="keywordflow">return</span>(0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_struct" href="struct_h5_f_d__file__image__callbacks__t.html">H5FD_file_image_callbacks_t</a> callbacks = {image_malloc, image_memcpy, image_realloc, image_free,</div>
<div class="line">                                           udata_copy, udata_free, (<span class="keywordtype">void</span> *)(&amp;udata)};</div>
<div class="line">    <span class="comment">// end of initialization</span></div>
<div class="line"> </div>
<div class="line">    &lt;allocate fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="group___f_a_p_l.html#ga14ea3598215afd078b964b672b40d63c">H5Pset_file_image_callbacks</a>(fapl_id, &amp;callbacks);</div>
<div class="line">    <span class="keywordflow">if</span> ( initial_file_open ) {</div>
<div class="line">        initial_file_open = FALSE;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> {</div>
<div class="line">        assert(udata.vfd_image_ptr != NULL);</div>
<div class="line">        assert(udata.vfd_image_size &gt; 0);</div>
<div class="line">        assert(udata.vfd_ref_count == 0);</div>
<div class="line">        assert(udata.fapl_ref_count == 0);</div>
<div class="line">        udata.fapl_image_ptr = udata.vfd_image_ptr;</div>
<div class="line">        udata.fapl_image_size = udata.vfd_image_size;</div>
<div class="line">        udata.vfd_image_ptr = NULL;</div>
<div class="line">        udata.vfd_image_size = 0;</div>
<div class="line">        <a class="code hl_function" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a>(fapl_id, udata.fapl_image_ptr, udata.fapl_image_size);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    &lt;open core file <span class="keyword">using </span>fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;discard fapl any time after the open&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;write/update the file, and then close it&gt;</div>
<div class="line"> </div>
<div class="line">    assert(udata.fapl_ref_count == 0);</div>
<div class="line">    assert(udata.vfd_ref_count == 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// udata.vfd_image_ptr and udata.vfd_image_size now contain the base address</span></div>
<div class="line">    <span class="comment">// and length of the final version of the core file</span></div>
<div class="line">    &lt;use the image of the file&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;repeat the above from the end of initialization to modify the file image as needed&gt;</div>
<div class="line"> </div>
<div class="line">    &lt;free the image when done&gt;</div>
</div><!-- fragment --><p>The above pseudo code shows how a buffer can be passed back and forth between the application and the HDF5 Library. The code also shows the application having control of the actual allocation, reallocation, and freeing of the buffer.</p>
<h3><a class="anchor" id="subsubsec_file_image_example_dp"></a>
Using HDF5 to Construct and Read a Data Packet</h3>
<p>Using the file image operations described in this document, we can bundle up data in an image of an HDF5 file on one process, transmit the image to a second process, and then open and read the image on the second process without any mandatory file system I/O.</p>
<p>We have already demonstrated the construction and reading of such buffers above, but it may be useful to offer an example of the full operation. We do so in the example below using as simple a set of calls as possible. The set of calls in the example has extra buffer allocations. To reduce extra buffer allocations, see the sections above.</p>
<p>In the following example, we construct an HDF5 file image on process A and then transmit the image to process B where we then open the image and extract the desired data. Note that no file system I/O is performed: all the processing is done in memory with the Core file driver.</p>
<p><em>Example 11. Building and passing a file image from one process to another</em> </p><table class="doxtable">
<tr>
<th>*** Process A ***</th><th>*** Process B *** </th></tr>
<tr>
<td><div class="fragment"><div class="line">&lt;Open and construct the desired file with the Core file driver&gt;</div>
<div class="line"><a class="code hl_function" href="group___h5_f.html#gae686870f0a276c4d06bbc667b2c24124">H5Fflush</a>(fid);</div>
<div class="line">size = <a class="code hl_function" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a>(fid, NULL, 0);</div>
<div class="line">buffer_ptr = malloc(size);</div>
<div class="line"><a class="code hl_function" href="group___h5_f.html#gadc53f4e76b1199cb5d2a8cb7fbb114ad">H5Fget_file_image</a>(fid, buffer_ptr, size);</div>
<div class="line">&lt;transmit size&gt;</div>
<div class="line">&lt;transmit *buffer_ptr&gt;</div>
<div class="line">free(buffer_ptr);</div>
<div class="line">&lt;close core file&gt;</div>
</div><!-- fragment -->  </td><td><div class="fragment"><div class="line"><a class="code hl_typedef" href="_h5_ipublic_8h.html#a0045db7ff9c22ad35db6ae91662e1943">hid_t</a> file_id;</div>
<div class="line">&lt;receive size&gt;</div>
<div class="line">buffer_ptr = malloc(size)</div>
<div class="line">&lt;receive image in *buffer_ptr&gt;</div>
<div class="line">file_id = <a class="code hl_function" href="group___h5_l_t.html#ga07fcf2af194e87a3e45252544ebe4aa4">H5LTopen_file_image</a>(buf,</div>
<div class="line"> buf_len,</div>
<div class="line"> <a class="code hl_define" href="_h5_l_tpublic_8h.html#a9f2c5bfc75d6c23f20c3a303934c20a8">H5LT_FILE_IMAGE_DONT_COPY</a>);</div>
<div class="line">&lt;read data from file, then close.</div>
<div class="line">note that the Core file driver</div>
<div class="line">will discard the buffer on close&gt;</div>
</div><!-- fragment -->  </td></tr>
</table>
<h3><a class="anchor" id="subsubsec_file_image_example_template"></a>
Using a Template File</h3>
<p>After the above examples, an example of the use of a template file might seem anti-climactic. A template file might be used to enforce consistency on file structure between files or in parallel HDF5 to avoid long sequences of collective operations to create the desired groups, datatypes, and possibly datasets. The following pseudo code outlines a potential use:</p>
<p><em>Example 12. Using a template file</em> </p><div class="fragment"><div class="line">&lt;allocate and initialize buf and buflen, with buf containing the desired initial</div>
<div class="line"> image (which in turn contains the desired group, datatype, and dataset</div>
<div class="line"> definitions), and buf_len containing the size of buf&gt;</div>
<div class="line"> </div>
<div class="line">&lt;allocate fapl_id&gt;</div>
<div class="line"> </div>
<div class="line">&lt;set fapl to use desired file driver that supports initial images&gt;</div>
<div class="line"> </div>
<div class="line">&lt;<a class="code hl_function" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2">H5Pset_file_image</a>(fapl_id, buf, buf_len);</div>
<div class="line"> </div>
<div class="line">&lt;discard buf any time after <span class="keyword">this</span> point&gt;</div>
<div class="line"> </div>
<div class="line">&lt;open file&gt;</div>
<div class="line"> </div>
<div class="line">&lt;discard fapl any time after <span class="keyword">this</span> point&gt;</div>
<div class="line"> </div>
<div class="line">&lt;read and/or write file as desired, close&gt;</div>
</div><!-- fragment --><p>Observe that the above pseudo code includes an unnecessary buffer allocation and copy in the call to <a class="el" href="group___f_a_p_l.html#ga31d0299f6ad287e013b2a02a8ccc1fa2" title="Sets an initial file image in a memory buffer.">H5Pset_file_image</a>. As we have already discussed ways of avoiding this, we will not address that issue here.</p>
<p>What is interesting in this case is to consider why the application would find this use case attractive.</p>
<p>In the serial case, at first glance there seems little reason to use the initial image facility at all. It is easy enough to use standard C calls to duplicate a template file, rename it as desired, and then open it as an HDF5 file.</p>
<p>However, this assumes that the template file will always be available and in the expected place. This is a questionable assumption for an application that will be widely distributed. Thus, we can at least make an argument for either keeping an image of the template file in the executable or for including code for writing the desired standard definitions to new HDF5 files.</p>
<p>Assuming the image is relatively small, we can further make an argument for the image in place of the code, as, quite simply, the image should be easier to maintain and modify with an HDF5 file editor.</p>
<p>However, there remains the question of why one should pass the image to the HDF5 Library instead of writing it directly with standard C calls and then using HDF5 to open it. Other than convenience and a slight reduction in code size, we are hard pressed to offer a reason.</p>
<p>In contrast, the argument is stronger in the parallel case since group, datatype, and dataset creations are all expensive collective operations. The argument is also weaker: simply copying an existing template file and opening it should lose many of its disadvantages in the HPC context although we would imagine that it is always useful to reduce the number of files in a deployment.</p>
<p>In closing, we would like to consider one last point. In the parallel case, we would expect template files to be quite large. Parallel HDF5 requires eager space allocation for chunked datasets. For similar reasons, we would expect template files in this context to contain long sequences of zeros with a scattering of metadata here and there. Such files would compress well, and the compressed images would be cheap to distribute across the available processes if necessary. Once distributed, each process could uncompress the image and write to file those sections containing actual data that lay within the section of the file assigned to the process. This approach might be significantly faster than a simple copy as it would allow sparse writes, and thus it might provide a compelling use case for template files. However, this approach would require extending our current API to allow compressed images. We would also have to add the H5Pget_image_decompression_callback/H5Pset_image_decompression_callback API calls. We see no problem in doing this. However, it is beyond the scope of the current effort, and thus we will not pursue the matter further unless there is interest in our doing so.</p>
<h2><a class="anchor" id="subsec_file_image_java"></a>
Java Signatures for File Image Operations API Calls</h2>
<p>Java function call signatures for the file image operation APIs have not yet been implemented, and there are no immediate plans for implementation.</p>
<h2><a class="anchor" id="subsec_file_image_fort"></a>
Fortran Signatures for File Image Operations API Calls</h2>
<p>Fortran function call signatures for the file image operation APIs are described in this section.</p>
<h3><a class="anchor" id="subsubsec_file_image_fort_low"></a>
Fortran Low-Level APIs</h3>
<p>The Fortran low-level APIs make use of Fortran 2003’s ISO_C_BINDING module in order to achieve portable and standard conforming interoperability with the C APIs. The C pointer (C_PTR) and function pointer (C_FUN_PTR) types are returned from the intrinsic procedures C_LOC(X) and C_FUNLOC(X), respectively, defined in the ISO_C_BINDING module. The argument X is the data or function to which the C pointers point to and must have the TARGET attribute in the calling program. Note that the variable name lengths of the Fortran equivalent of the predefined C constants were shortened to less than 31 characters in order to be Fortran standard compliant.</p>
<table class="doxtable">
<tr>
<th>h5pget_file_image_f </th></tr>
<tr>
<td><div class="fragment"><div class="line">SUBROUTINE h5pget_file_image_f(fapl_id, buf_ptr, buf_len_ptr, hdferr)</div>
<div class="line">    IMPLICIT NONE</div>
<div class="line">    INTEGER(HID_T) , INTENT(IN)               :: fapl_id</div>
<div class="line">    TYPE(C_PTR)    , INTENT(IN), DIMENSION(*) :: buf_ptr</div>
<div class="line">    INTEGER(SIZE_T), INTENT(OUT)              :: buf_len_ptr</div>
<div class="line">    INTEGER        , INTENT(OUT)              :: hdferr</div>
</div><!-- fragment -->  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>h5pset_file_image_f </th></tr>
<tr>
<td><div class="fragment"><div class="line">SUBROUTINE h5pset_file_image_f(fapl_id, buf_ptr, buf_len, hdferr)</div>
<div class="line">    IMPLICIT NONE</div>
<div class="line">    INTEGER(HID_T) , INTENT(IN)  :: fapl_id</div>
<div class="line">    TYPE(C_PTR)    , INTENT(IN)  :: buf_ptr</div>
<div class="line">    INTEGER(SIZE_T), INTENT(IN)  :: buf_len</div>
<div class="line">    INTEGER        , INTENT(OUT) :: hdferr</div>
</div><!-- fragment -->  </td></tr>
</table>
<table class="doxtable">
<tr>
<th>h5fget_file_image_f </th></tr>
<tr>
<td><div class="fragment"><div class="line">SUBROUTINE h5fget_file_image_f(file_id, buf_ptr, buf_len, hdferr, buf_size)</div>
<div class="line">    IMPLICIT NONE</div>
<div class="line">    INTEGER(HID_T) , INTENT(IN)              :: file_id</div>
<div class="line">    TYPE(C_PTR)    , INTENT(INOUT)           :: buf_ptr</div>
<div class="line">    INTEGER(SIZE_T), INTENT(IN)              :: buf_len</div>
<div class="line">    INTEGER        , INTENT(OUT)             :: hdferr</div>
<div class="line">    INTEGER(SIZE_T), INTENT(OUT)  , OPTIONAL :: buf_size</div>
</div><!-- fragment -->  </td></tr>
</table>
<h3><a class="anchor" id="subsubsec_file_image_fort_high"></a>
Fortran High-Level APIs</h3>
<p>Fortran function call signatures for the file image operation APIs have not yet been implemented yet.</p>
<p>Previous Chapter <a class="el" href="_h5_v_l__u_g.html#sec_vol">The HDF5 Virtual Object Layer (VOL)</a> - Next Chapter <a class="el" href="_h5_e_s__u_g.html#sec_async">The HDF5 Event Set Interface</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
