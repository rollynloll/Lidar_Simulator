<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HDF5: Dataset Chunking Issues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="hdf5doxy.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="hdf5doxy.css" rel="stylesheet" type="text/css">
<script type="text/javascript" src="hdf5_navtree_hacks.js"></script>
<div style="background:#FFDDDD;font-size:120%;text-align:center;margin:0;padding:5px">Please, help us to better serve our user community by answering the following short survey:  <a href="https://www.hdfgroup.org/website-survey/">https://www.hdfgroup.org/website-survey/</a></div>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="HDFG-logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">HDF5<span id="projectnumber">&#160;1.14.6</span>
   </div>
   <div id="projectbrief">API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="_getting_started.html"><span>Getting&#160;started</span></a></li>
      <li><a href="_u_g.html"><span>User&#160;Guide</span></a></li>
      <li><a href="_r_m.html"><span>Reference&#160;Manual</span></a></li>
      <li><a href="_cookbook.html"><span>Cookbook</span></a></li>
      <li><a href="_t_n.html"><span>Technical&#160;Notes</span></a></li>
      <li><a href="_r_f_c.html"><span>RFCs</span></a></li>
      <li><a href="_s_p_e_c.html"><span>Specifications</span></a></li>
      <li><a href="_g_l_s.html"><span>Glossary</span></a></li>
      <li><a href="_f_t_s.html"><span>Full-Text&#160;Search</span></a></li>
      <li><a href="_about.html"><span>About</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('hdf5_chunk_issues.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Dataset Chunking Issues</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_hdf5_chunk_issues_intro"></a>
Introduction</h1>
<p><b>Chunking</b> refers to a storage layout where a dataset is partitioned into fixed-size multi-dimensional chunks. The chunks cover the dataset but the dataset need not be an integral number of chunks. If no data is ever written to a chunk then that chunk isn't allocated on disk. Figure 1 shows a 25x48 element dataset covered by nine 10x20 chunks and 11 data points written to the dataset. No data was written to the region of the dataset covered by three of the chunks so those chunks were never allocated in the file &ndash; the other chunks are allocated at independent locations in the file and written in their entirety.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f1.gif" alt=""/>
<div class="caption">
Figure 1</div></div>
   </td></tr>
</table>
<p>The HDF5 library treats chunks as atomic objects &ndash; disk I/O is always in terms of complete chunks (parallel versions of the library can access individual bytes of a chunk when the underlying file uses MPI-IO.). This allows data filters to be defined by the application to perform tasks such as compression, encryption, checksumming, etc. on entire chunks. As shown in Figure 2, if <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> touches only a few bytes of the chunk, the entire chunk is read from the file, the data passes upward through the filter pipeline, the few bytes are modified, the data passes downward through the filter pipeline, and the entire chunk is written back to the file.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f2.gif" alt=""/>
<div class="caption">
Figure 2</div></div>
   </td></tr>
</table>
<h1><a class="anchor" id="sec_hdf5_chunk_issues_data"></a>
The Raw Data Chunk Cache</h1>
<p>It's obvious from Figure 2 that calling <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> many times from the application would result in poor performance even if the data being written all falls within a single chunk. A raw data chunk cache layer was added between the top of the filter stack and the bottom of the byte modification layer. By default, the chunk cache will store 521 chunks or 1MB of data (whichever is less) but these values can be modified with <a class="el" href="group___f_a_p_l.html#ga034a5fc54d9b05296555544d8dd9fe89" title="Sets the raw data chunk cache parameters.">H5Pset_cache</a>.</p>
<p>The preemption policy for the cache favors certain chunks and tries not to preempt them. </p><ul>
<li>Chunks that have been accessed frequently in the near past are favored. </li>
<li>A chunk which has just entered the cache is favored. </li>
<li>A chunk which has been completely read or completely written but not partially read or written is penalized according to some application specified weighting between zero and one. </li>
<li>A chunk which is larger than the maximum cache size is not eligible for caching.</li>
</ul>
<h1><a class="anchor" id="sec_hdf5_chunk_issues_effic"></a>
Cache Efficiency</h1>
<p>Now for some real numbers... A 2000x2000 element dataset is created and covered by a 20x20 array of chunks (each chunk is 100x100 elements). The raw data cache is adjusted to hold at most 25 chunks by setting the maximum number of bytes to 25 times the chunk size in bytes. Then the application creates a square, two-dimensional memory buffer and uses it as a window into the dataset, first reading and then rewriting in row-major order by moving the window across the dataset (the read and write tests both start with a cold cache).</p>
<p>The measure of efficiency in Figure 3 is the number of bytes requested by the application divided by the number of bytes transferred from the file. There are at least a couple ways to get an estimate of the cache performance: one way is to turn on cache debugging and look at the number of cache misses. A more accurate and specific way is to register a data filter whose sole purpose is to count the number of bytes that pass through it (that's the method used below).</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f3.gif" alt=""/>
<div class="caption">
Figure 3</div></div>
   </td></tr>
</table>
<p>The read efficiency is less than one for two reasons: collisions in the cache are handled by preempting one of the colliding chunks, and the preemption algorithm occasionally preempts a chunk which hasn't been referenced for a long time but is about to be referenced in the near future.</p>
<p>The write test results in lower efficiency for most window sizes because HDF5 is unaware that the application is about to overwrite the entire dataset and must read in most chunks before modifying parts of them.</p>
<p>There is a simple way to improve efficiency for this example. It turns out that any chunk that has been completely read or written is a good candidate for preemption. If we increase the penalty for such chunks from the default 0.75 to the maximum 1.00 then efficiency improves.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f4.gif" alt=""/>
<div class="caption">
Figure 4</div></div>
   </td></tr>
</table>
<p>The read efficiency is still less than one because of collisions in the cache. The number of collisions can often be reduced by increasing the number of slots in the cache. Figure 5 shows what happens when the maximum number of slots is increased by an order of magnitude from the default (this change has no major effect on memory used by the test since the byte limit was not increased for the cache).</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f5.gif" alt=""/>
<div class="caption">
Figure 5</div></div>
   </td></tr>
</table>
<p>Although the application eventually overwrites every chunk completely the library has no way of knowing this beforehand since most calls to <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> modify only a portion of any given chunk. Therefore, the first modification of a chunk will cause the chunk to be read from disk into the chunk buffer through the filter pipeline. Eventually HDF5 might contain a dataset transfer property that can turn off this read operation resulting in write efficiency which is equal to read efficiency.</p>
<h1><a class="anchor" id="sec_hdf5_chunk_issues_frag"></a>
Fragmentation</h1>
<p>Even if the application transfers the entire dataset contents with a single call to <a class="el" href="group___h5_d.html#ga8287d5a7be7b8e55ffeff68f7d26811c" title="Reads raw data from a dataset into a provided buffer.">H5Dread</a> or <a class="el" href="group___h5_d.html#ga98f44998b67587662af8b0d8a0a75906" title="Writes raw data from a buffer to a dataset.">H5Dwrite</a> it's possible the request will be broken into smaller, more manageable pieces by the library. This is almost certainly true if the data transfer includes a type conversion.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="Chunk_f6.gif" alt=""/>
<div class="caption">
Figure 6</div></div>
   </td></tr>
</table>
<p>By default the strip size is 1MB but it can be changed by calling <a class="el" href="group___d_x_p_l.html#ga777e8c171c9e462230a9fa40874b38ce" title="Sets type conversion and background buffers.">H5Pset_buffer</a>.</p>
<h1><a class="anchor" id="sec_hdf5_chunk_issues_store"></a>
File Storage Overhead</h1>
<p>The chunks of the dataset are allocated at independent locations throughout the HDF5 file and a B-tree maps chunk N-dimensional addresses to file addresses. The more chunks that are allocated for a dataset the larger the B-tree.</p>
<p>Large B-trees have two disadvantages: </p><ul>
<li>The file storage overhead is higher and more disk I/O is required to traverse the tree from root to leaves. </li>
<li>The increased number of B-tree nodes will result in higher contention for the metadata cache. There are three ways to reduce the number of B-tree nodes. The obvious way is to reduce the number of chunks by choosing a larger chunk size (doubling the chunk size will cut the number of B-tree nodes in half). Another method is to adjust the split ratios for the B-tree by calling <a class="el" href="group___d_x_p_l.html#ga51d126d64fa766d44160a95057a2c733" title="Sets B-tree split ratios for a dataset transfer property list.">H5Pset_btree_ratios</a>, but this method typically results in only a slight improvement over the default settings. Finally, the out-degree of each node can be increased by calling <a class="el" href="group___f_c_p_l.html#ga84a72f59d17841c37ab34674bf22a10c" title="Sets the size of the parameter used to control the B-trees for indexing chunked datasets.">H5Pset_istore_k</a> (increasing the out degree actually increases file overhead while decreasing the number of nodes).</li>
</ul>
<h1><a class="anchor" id="sec_hdf5_chunk_issues_comp"></a>
Chunk Compression</h1>
<p>Dataset chunks can be compressed through the use of filters. See the chapter <a class="el" href="_h5_d__u_g.html#subsec_dataset_filters">Using HDF5 Filters</a> in the <a class="el" href="_u_g.html">HDF5 User Guide</a>.</p>
<p>Reading and rewriting compressed chunked data can result in holes in an HDF5 file. In time, enough such holes can increase the file size enough to impair application or library performance when working with that file. See <a class="el" href="_h5_t_o_o_l__r_p__u_g.html">The HDF5 h5repack Tool</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
